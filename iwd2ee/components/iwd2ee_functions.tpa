OUTER_PATCH creature_constants BEGIN
	creflags=0x10
	killxp=0x14
	xp=0x18
	gold=0x1c
	states=0x20
	currenthp=0x24
	maxhp=0x26
	maximumhp=0x26
	animation=0x28
	metalcolor=0x2c
	minorcolor=0x2d
	majorcolor=0x2e
	skincolor=0x2f
	leathercolor=0x30
	armorcolor=0x31
	haircolor=0x32
	smallportrait=0x34
	largeportrait=0x3c
	armorclass=0x46
	baseattackbonus=0x50
	attacksperround=0x51
	fortitudesave=0x52
	reflexsave=0x53
	willsave=0x54
	fireresistance=0x55
	coldresistance=0x56
	elecresistance=0x57
	electricityresistance=0x57
	acidresistance=0x58
	spellresistance=0x59
	magicfireresistance=0x5a
	magiccoldresistance=0x5b
	slashingresistance=0x5c
	crushingresistance=0x5d
	bludgeoningresistance=0x5d
	piercingresistance=0x5e
	missileresistance=0x5f
	magicdamageresistance=0x60
	luck=0x67
	turnundeadlevel=0x68
	leveltotal=0x8a
	levelbarbarian=0x8b
	levelbard=0x8c
	levelcleric=0x8d
	leveldruid=0x8e
	levelfighter=0x8f
	levelmonk=0x90
	levelpaladin=0x91
	levelranger=0x92
	levelrogue=0x93
	levelsorcerer=0x94
	levelwizard=0x95
	extraflags=0x1a4
	teamscript=0x1ac
	specialscript1=0x1b4
	enchantmentlevel=0x1bc
	feats1=0x1c0
	feats2=0x1c4
	feats3=0x1c8
	proficiencybow=0x1d8
	proficiencycrossbow=0x1d9
	proficiencymissile=0x1da
	proficiencyaxe=0x1db
	proficiencymace=0x1dc
	proficiencyflail=0x1dd
	proficiencypolearm=0x1de
	proficiencyhammer=0x1df
	proficiencystaff=0x1e0
	proficiencyquarterstaff=0x1e0
	proficiencygreatsword=0x1e1
	proficiencylargesword=0x1e2
	proficiencysmallblade=0x1e3
	toughness=0x1e4
	armoredarcana=0x1e5
	cleave=0x1e6
	armorproficiency=0x1e7
	spellfocusenchantment=0x1e8
	spellfocusevocation=0x1e9
	spellfocusnecromancy=0x1ea
	spellfocustransmutation=0x1eb
	spellpenetration=0x1ec
	extrarage=0x1ed
	extrawildshape=0x1ee
	extrasmiting=0x1ef
	extraturning=0x1f0
	proficiencybastardsword=0x1f1
	skillalchemy=0x218
	skillanimalempathy=0x219
	skillbluff=0x21a
	skillconcentration=0x21b
	skilldiplomacy=0x21c
	skilldisabledevice=0x21d
	skillhide=0x21e
	skillintimidate=0x21f
	skilllore=0x220
	skillknowledgearcana=0x220
	skillmovesilently=0x221
	skillopenlocks=0x222
	skillpickpockets=0x223
	skillsearch=0x224
	skillspellcraft=0x225
	skillusemagicdevice=0x226
	skillwildernesslore=0x227
	challengerating=0x25a
	favoredenemy1=0x25b
	favoredenemy2=0x25c
	favoredenemy3=0x25d
	favoredenemy4=0x25e
	favoredenemy5=0x25f
	favoredenemy6=0x260
	favoredenemy7=0x261
	favoredenemy8=0x262
	subrace=0x263
	strength=0x266
	intelligence=0x267
	wisdom=0x268
	dexterity=0x269
	constitution=0x26a
	charisma=0x26b
	morale=0x26c
	moralebreak=0x26d
	moralerecovery=0x26e
	kit=0x270
	overridescript=0x274
	specialscript2=0x27c
	combatscript=0x284
	specialscript3=0x28c
	movementscript=0x294
	defaultvisibility=0x29c
	deathvariableset=0x2aa
	deathvariableincrement=0x2ca
	fadeamount=0x301
	attributes=0x303
	allegiance=0x384
	general=0x385
	race=0x386
	class=0x387
	specifics=0x388
	gender=0x389
	alignment=0x38f
	scriptname=0x394
	class2=0x3b4
	classmask=0x3b6
	dialog=0x626
	dialogue=0x626

	actorsize=0x110
	regionsize=0xc4
	doorsize=0xc8
END

DEFINE_PATCH_FUNCTION ~ALTER_AREA_ACTOR_IWD2~
	INT_VAR
		spawned=~-1~
		animation=~-1~
		orient=~-1~
		expiry=~-2~
		wander=~-1~
		follow=~-1~
		times_talked=~-1~
		flag_cre_unattached=~-1~
		flag_seen_party=~-1~
		flag_invulnerable=~-1~
		flag_override_script_name=~-1~
		flag_difficulty_1=~-1~
		flag_difficulty_2=~-1~
		flag_difficulty_3=~-1~
		flag_time_set=0
		flag_time_unset=0
		x_coord=~-1~
		y_coord=~-1~
		dest_x=~-1~
		dest_y=~-1~
	STR_VAR
		actor_name=~~
		match_cre_file=~~
		cre_file=~same~
		dlg_file=~same~
		script_override=~same~
		script_special3=~same~
		script_special2=~same~
		script_combat=~same~
		script_movement=~same~
		script_team=~same~
		script_special1=~same~
BEGIN
	PATCH_IF (dest_x = (0 - 1)) BEGIN
		dest_x = x_coord
	END
	PATCH_IF (dest_y = (0 - 1)) BEGIN
		dest_y = y_coord
	END
	actor_name_length = (STRING_LENGTH ~%actor_name%~)
	cre_file_length = (STRING_LENGTH ~%match_cre_file%~)
	actor_found = 0
	READ_SHORT 0x68 actornumber
	READ_LONG 0x64 actoroffset
	FOR (i = 0; i < actornumber; ++i) BEGIN
		offset = actoroffset + (i * 0x110)
		READ_ASCII offset name_of_actor (actor_name_length)
		READ_ASCII (offset + 0x80) cre_file_of_actor (cre_file_length)

		PATCH_IF ((actor_name_length = 0) OR (~%name_of_actor%~ STRING_EQUAL_CASE ~%actor_name%~)) AND ((cre_file_length = 0) OR (~%cre_file_of_actor%~ STRING_EQUAL_CASE ~%match_cre_file%~)) BEGIN
			actor_found = 1
			PATCH_IF (x_coord != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x20) x_coord
			END
			PATCH_IF (y_coord != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x22) y_coord
			END
			PATCH_IF (dest_x != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x24) dest_x
			END
			PATCH_IF (dest_y != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x26) dest_y
			END
			PATCH_IF (spawned != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x2c) spawned
			END
			PATCH_IF (animation != (0 - 1)) BEGIN
				WRITE_LONG (offset + 0x30) animation
			END
			PATCH_IF (orient != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x34) orient
			END
			PATCH_IF (expiry != (0 - 2)) BEGIN
				WRITE_LONG (offset + 0x38) expiry
			END
			PATCH_IF (wander != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x3c) wander
			END
			PATCH_IF (follow != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x3e) follow
			END
			PATCH_IF (times_talked != (0 - 1)) BEGIN
				WRITE_LONG (offset + 0x44) times_talked
			END
			PATCH_IF (!(~%dlg_file%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x48) ~%dlg_file%~ #8
			END
			PATCH_IF (!(~%script_override%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x50) ~%script_override%~ #8
			END
			PATCH_IF (!(~%script_special3%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x58) ~%script_special3%~ #8
			END
			PATCH_IF (!(~%script_special2%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x60) ~%script_special2%~ #8
			END
			PATCH_IF (!(~%script_combat%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x68) ~%script_combat%~ #8
			END
			PATCH_IF (!(~%script_movement%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x70) ~%script_movement%~ #8
			END
			PATCH_IF (!(~%script_team%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x78) ~%script_team%~ #8
			END
			PATCH_IF (!(~%cre_file%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x80) ~%cre_file%~ #8
			END
			PATCH_IF (!(~%script_special1%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x90) ~%script_special1%~ #8
			END

			bit_enable = 0
			bit_disable = 0xFFFFFFFF
			PATCH_IF (flag_cre_unattached == 0) BEGIN
				bit_disable -= 0x1
			END ELSE BEGIN
				PATCH_IF (flag_cre_unattached > 0) BEGIN
					bit_enable += 0x1
				END
			END
			PATCH_IF (flag_seen_party == 0) BEGIN
				bit_disable -= 0x2
			END ELSE BEGIN
				PATCH_IF (flag_seen_party > 0) BEGIN
					bit_enable += 0x2
				END
			END
			PATCH_IF (flag_invulnerable == 0) BEGIN
				bit_disable -= 0x4
			END ELSE BEGIN
				PATCH_IF (flag_invulnerable > 0) BEGIN
					bit_enable += 0x4
				END
			END
			PATCH_IF (flag_override_script_name == 0) BEGIN
				bit_disable -= 0x8
			END ELSE BEGIN
				PATCH_IF (flag_override_script_name > 0) BEGIN
					bit_enable += 0x8
				END
			END
			READ_LONG (offset + 0x28) flag_change
			flag_change |= bit_enable
			flag_change &= bit_disable
			WRITE_LONG (offset + 0x28) flag_change

			bit_enable = 0
			bit_disable = 0xFFFFFFFF
			PATCH_IF (flag_difficulty_1 == 0) BEGIN
				bit_disable -= 0x1
			END ELSE BEGIN
				PATCH_IF (flag_difficulty_1 > 0) BEGIN
					bit_enable += 0x1
				END
			END
			PATCH_IF (flag_difficulty_2 == 0) BEGIN
				bit_disable -= 0x2
			END ELSE BEGIN
				PATCH_IF (flag_difficulty_2 > 0) BEGIN
					bit_enable += 0x2
				END
			END
			PATCH_IF (flag_difficulty_3 == 0) BEGIN
				bit_disable -= 0x4
			END ELSE BEGIN
				PATCH_IF (flag_difficulty_3 > 0) BEGIN
					bit_enable += 0x4
				END
			END
			READ_BYTE (offset + 0x2f) flag_change
			flag_change |= bit_enable
			flag_change &= bit_disable
			WRITE_BYTE (offset + 0x2f) flag_change

			bit_enable = 0
			bit_disable = 0xFFFFFFFF
			bit_enable += flag_time_set
			bit_disable -= flag_time_unset
			READ_LONG (offset + 0x40) flag_change
			flag_change |= bit_enable
			flag_change &= bit_disable
			WRITE_LONG (offset + 0x40) flag_change
		END
	END
	PATCH_IF (actor_found = 0) BEGIN
		PATCH_IF actor_name_length > 0 AND cre_file_length > 0 BEGIN
			PATCH_WARN ~No actor called %actor_name% or with the resource %match_cre_file%.CRE was found.~
		END
		PATCH_IF actor_name_length > 0 AND cre_file_length = 0 BEGIN
			PATCH_WARN ~No actor called %actor_name% was found.~
		END
		PATCH_IF actor_name_length = 0 AND cre_file_length > 0 BEGIN
			PATCH_WARN ~No actor with the resource %match_cre_file%.CRE was found.~
		END
	END

END

DEFINE_PATCH_FUNCTION ~ALTER_AREA_REGION_IWD2~
	INT_VAR
		type=~-1~
		cursor=~-1~
		trap_detect=~-1~
		trap_remove=~-1~
		trapped=~-1~
		detected=~-1~
		all_flags=~-1~
		flag_locked=~-1~
		flag_resets=~-1~
		flag_party_required=~-1~
		flag_trap_detectable=~-1~
		flag_trap_enemies=~-1~
		flag_tutorial=~-1~
		flag_trap_npcs=~-1~
		flag_silent=~-1~
		flag_deactivated=~-1~
		flag_impassable_npc=~-1~
		flag_activation_point=~-1~
		flag_connect_to_door=~-1~
		bounding_left=~-1~
		bounding_top=~-1~
		bounding_right=~-1~
		bounding_bottom=~-1~
		info_point=99999999
		launch_x=~-1~
		launch_y=~-1~
		activate_x=~-1~
		activate_y=~-1~
		alternate_x=~-1~
		alternate_y=~-1~
	STR_VAR
		region_name=~~
		destination_area=~same~
		entrance_name=~same~
		region_key=~same~
		region_script=~same~
BEGIN
	SET region_name_length = (STRING_LENGTH ~%region_name%~)
		PATCH_IF (region_name_length = 0) BEGIN
			PATCH_FAIL ~No region name given for function ALTER_AREA_REGION_IWD2 ~
		END
	SET region_found = 0
	READ_SHORT 0x6a regionnumber
	READ_LONG 0x6c regionoffset
	FOR (i = 0; i < regionnumber; ++i) BEGIN
		SET offset = regionoffset + (i * 0xc4)
		READ_ASCII offset name_of_region (region_name_length)
		PATCH_IF (~%name_of_region%~ STRING_EQUAL_CASE ~%region_name%~) BEGIN
			region_found = 1
			PATCH_IF (type != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x20) type
			END
			PATCH_IF (bounding_left != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x22) bounding_left
			END
			PATCH_IF (bounding_top != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x24) bounding_top
			END
			PATCH_IF (bounding_right != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x26) bounding_right
			END
			PATCH_IF (bounding_bottom != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x28) bounding_bottom
			END
			PATCH_IF (cursor != (0 - 1)) BEGIN
				WRITE_LONG (offset + 0x34) cursor
			END
			PATCH_IF (!(~%destination_area%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x38) ~%destination_area%~ #8
			END
			PATCH_IF (!(~%entrance_name%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x40) ~%entrance_name%~ #32
			END
			PATCH_IF (info_point != 99999999) BEGIN
				WRITE_LONG (offset + 0x64) info_point
			END
			PATCH_IF (trap_detect != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x68) trap_detect
			END
			PATCH_IF (trap_remove != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x6a) trap_remove
			END
			PATCH_IF (trapped != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x6c) trapped
			END
			PATCH_IF (detected != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x6e) detected
			END
			PATCH_IF (launch_x != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x70) launch_x
			END
			PATCH_IF (launch_y != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x72) launch_y
			END
			PATCH_IF (!(~%region_key%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x74) ~%region_key%~ #8
			END
			PATCH_IF (!(~%region_script%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x7c) ~%region_script%~ #8
			END
			PATCH_IF (activate_x != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x84) activate_x
			END
			PATCH_IF (activate_y != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x86) activate_y
			END
			PATCH_IF (alternate_x != (0 - 1)) BEGIN
				WRITE_LONG (offset + 0x88) alternate_x
			END
			PATCH_IF (alternate_y != (0 - 1)) BEGIN
				WRITE_LONG (offset + 0x9c) alternate_y
			END
			PATCH_IF (all_flags != (0 - 1)) BEGIN
				WRITE_LONG (offset + 0x60) all_flags
			END
			i = regionnumber
		END
	END
	PATCH_IF (region_found = 0) BEGIN
		PATCH_WARN ~No region called %region_name% was found.~
	END

END

DEFINE_PATCH_FUNCTION ~ALTER_AREA_CONTAINER_IWD2~
	INT_VAR
		x_coord=~-1~
		y_coord=~-1~
		type=~-1~
		lock_difficulty=~-1~
		trap_detect=~-1~
		trap_remove=~-1~
		trapped=~-1~
		detected=~-1~
		all_flags=~-1~
		launch_x=~-1~
		launch_y=~-1~
		unlock_message=99999999
	STR_VAR
		container_name=~~
		container_open_sound=~same~
		container_close_sound=~same~
		container_key=~same~
		container_script=~same~
		travel_trigger=~same~
		dialogue=~same~
BEGIN
	SET container_name_length = (STRING_LENGTH ~%container_name%~)
		PATCH_IF (container_name_length = 0) BEGIN
			PATCH_FAIL ~No container name given for function ALTER_AREA_CONTAINER_IWD2 ~
		END
	SET container_found = 0
	READ_LONG 0x80 containeroffset
	READ_SHORT 0x84 containernumber
	FOR (i = 0; i < containernumber; ++i) BEGIN
		SET offset = containeroffset + (i * 0xc0)
		READ_ASCII offset name_of_container (container_name_length)
		PATCH_IF (~%name_of_container%~ STRING_EQUAL_CASE ~%container_name%~) BEGIN
			container_found = 1
			PATCH_IF (x_coord != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x20) x_coord
			END
			PATCH_IF (y_coord != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x22) y_coord
			END
			PATCH_IF (type != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x24) type
			END
			PATCH_IF (lock_difficulty != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x26) lock_difficulty
			END
			PATCH_IF (all_flags != (0 - 1)) BEGIN
				WRITE_LONG (offset + 0x28) all_flags
			END
			PATCH_IF (trap_detect != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x2c) trap_detect
			END
			PATCH_IF (trap_remove != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x2e) trap_remove
			END
			PATCH_IF (trapped != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x30) trapped
			END
			PATCH_IF (detected != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x32) detected
			END
			PATCH_IF (launch_x != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x34) launch_x
			END
			PATCH_IF (launch_y != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x36) launch_y
			END
			PATCH_IF (!(~%container_key%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x78) ~%container_key%~ #8
			END
			PATCH_IF (!(~%container_script%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x48) ~%container_script%~ #8
			END
			PATCH_IF (unlock_message != 99999999) BEGIN
				WRITE_LONG (offset + 0x84) unlock_message
			END

			i = containernumber
		END
	END
	PATCH_IF (container_found = 0) BEGIN
		PATCH_WARN ~No container called %container_name% was found.~
	END
END

DEFINE_PATCH_FUNCTION ~ALTER_AREA_DOOR_IWD2~
	INT_VAR
		cursor=~-1~
		trap_detect=~-1~
		trap_remove=~-1~
		trapped=~-1~
		detected=~-1~
		all_flags=~-1~
		flag_open=~-1~
		flag_locked=~-1~
		flag_resets=~-1~
		flag_detectable=~-1~
		flag_forced=~-1~
		flag_no_close=~-1~
		flag_located=~-1~
		flag_secret=~-1~
		flag_detected=~-1~
		flag_string=~-1~
		flag_no_look=~-1~
		flag_uses_key=~-1~
		flag_sliding=~-1~
		launch_x=~-1~
		launch_y=~-1~
		door_detect=~-1~
		lock_difficulty=~-1~
		open_x=~-1~
		open_y=~-1~
		close_x=~-1~
		close_y=~-1~
		unlock_message=99999999
	STR_VAR
		door_name=~~
		door_open_sound=~same~
		door_close_sound=~same~
		door_key=~same~
		door_script=~same~
		travel_trigger=~same~
		dialogue=~same~
BEGIN
	SET door_name_length = (STRING_LENGTH ~%door_name%~)
		PATCH_IF (door_name_length = 0) BEGIN
			PATCH_FAIL ~No door name given for function ALTER_AREA_DOOR_IWD2 ~
		END
	SET door_found = 0
	READ_SHORT 0xb4 doornumber
	READ_LONG 0xb8 dooroffset
	FOR (i = 0; i < doornumber; ++i) BEGIN
		SET offset = dooroffset + (i * 0xc8)
		READ_ASCII offset name_of_door (door_name_length)
		PATCH_IF (~%name_of_door%~ STRING_EQUAL_CASE ~%door_name%~) BEGIN
			door_found = 1
			PATCH_IF (all_flags != (0 - 1)) BEGIN
				WRITE_LONG (offset + 0x28) all_flags
/*			END ELSE BEGIN
				SET bit_enable = 0
				SET bit_disable = 0xFFFFFFFF
				PATCH_IF (flag_open != (0 - 1)) BEGIN
					PATCH_IF (flag_open == 0) BEGIN
						bit_disable -= 0x1
					END ELSE BEGIN 
						bit_enable += 0x1
					END
					PATCH_IF (flag_locked == 0) BEGIN
						bit_disable -= 0x2
					END ELSE BEGIN 
						bit_enable += 0x2
					END
					PATCH_IF (flag_resets == 0) BEGIN
						bit_disable -= 0x4
					END ELSE BEGIN 
						bit_enable += 0x4
					END
					PATCH_IF (flag_detectable == 0) BEGIN
						bit_disable -= 0x8
					END ELSE BEGIN 
						bit_enable += 0x8
					END
					PATCH_IF (flag_forced == 0) BEGIN
						bit_disable -= 0x10
					END ELSE BEGIN 
						bit_enable += 0x10
					END
					PATCH_IF (flag_no_close == 0) BEGIN
						bit_disable -= 0x20
					END ELSE BEGIN 
						bit_enable += 0x20
					END
					PATCH_IF (flag_located == 0) BEGIN
						bit_disable -= 0x40
					END ELSE BEGIN 
						bit_enable += 0x40
					END
					PATCH_IF (flag_secret == 0) BEGIN
						bit_disable -= 0x80
					END ELSE BEGIN 
						bit_enable += 0x80
					END
					PATCH_IF (flag_detected == 0) BEGIN
						bit_disable -= 0x100
					END ELSE BEGIN 
						bit_enable += 0x100
					END
					PATCH_IF (flag_string == 0) BEGIN
						bit_disable -= 0x200
					END ELSE BEGIN 
						bit_enable += 0x200
					END
					PATCH_IF (flag_no_look == 0) BEGIN
						bit_disable -= 0x400
					END ELSE BEGIN 
						bit_enable += 0x400
					END
					PATCH_IF (flag_uses_key == 0) BEGIN
						bit_disable -= 0x4000
					END ELSE BEGIN 
						bit_enable += 0x4000
					END
				END
				READ_LONG (offset + 0x28) flag_change
				flag_change |= bit_enable
				flag_change &= bit_disable
				WRITE_LONG (offset + 0x28) flag_change */
			END
			PATCH_IF (cursor != (0 - 1)) BEGIN
				WRITE_LONG (offset + 0x68) cursor
			END
			PATCH_IF (trap_detect != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x6c) trap_detect
			END
			PATCH_IF (trap_remove != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x6e) trap_remove
			END
			PATCH_IF (trapped != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x70) trapped
			END
			PATCH_IF (detected != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x72) detected
			END
			PATCH_IF (launch_x != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x74) launch_x
			END
			PATCH_IF (launch_y != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x76) launch_y
			END
			PATCH_IF (!(~%door_key%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x78) ~%door_key%~ #8
			END
			PATCH_IF (!(~%door_script%~ STRING_EQUAL ~same~)) BEGIN
				WRITE_ASCIIE (offset + 0x80) ~%door_script%~ #8
			END
			PATCH_IF (door_detect != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x88) door_detect
			END
			PATCH_IF (lock_difficulty != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x8c) lock_difficulty
			END
			PATCH_IF (open_x != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x90) open_x
			END
			PATCH_IF (open_y != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0x92) open_y
			END
			PATCH_IF (close_x != (0 - 1)) BEGIN
				WRITE_LONG (offset + 0x94) close_x
			END
			PATCH_IF (close_y != (0 - 1)) BEGIN
				WRITE_LONG (offset + 0x96) close_y
			END
			PATCH_IF (unlock_message != 99999999) BEGIN
				WRITE_LONG (offset + 0x98) unlock_message
			END

			i = doornumber
		END
	END
	PATCH_IF (door_found = 0) BEGIN
		PATCH_WARN ~No door called %door_name% was found.~
	END
END
/*
DEFINE_PATCH_FUNCTION ~ADD_AREA_ITEM_IWD2~
	INT_VAR
		container_to_add_to=~1~
		charges1=0
		charges2=0
		charges3=0
	STR_VAR
		item_to_add=~~
		flags=~~
BEGIN
	READ_LONG 0x64 actoroffset
	READ_LONG 0x6C triggeroffset
	READ_LONG 0x70 spawnpointoffset
	READ_LONG 0x78 entranceoffset
	READ_LONG 0x80 containeroffset
	READ_LONG 0x88 itemoffset
	READ_LONG 0x8C vertexoffset
	READ_LONG 0x94 ambientoffset
	READ_LONG 0x98 variableoffset
	READ_LONG 0xA0 objectflagoffset
	READ_LONG 0xB0 bitmapoffset
	READ_LONG 0xB8 dooroffset
	READ_LONG 0xC0 animationoffset
	READ_LONG 0xC8 actoroffset
END
*/








	//	v1.0
	DEFINE_ACTION_MACRO	IWD2_INDEX_LISTS	BEGIN
		COPY_EXISTING	~LISTINNT.2DA~	override
			CLEAR_ARRAY	~IDX_LISTINNT~
			READ_2DA_ENTRIES_NOW	~IDX_LISTINNT~	2
		BUT_ONLY
		COPY_EXISTING	~LISTSONG.2DA~	override
			CLEAR_ARRAY	~IDX_LISTSONG~
			READ_2DA_ENTRIES_NOW	~IDX_LISTSONG~	2
		BUT_ONLY
		COPY_EXISTING	~LISTSHAP.2DA~	override
			CLEAR_ARRAY	~IDX_LISTSHAP~
			READ_2DA_ENTRIES_NOW	~IDX_LISTSHAP~	2
		BUT_ONLY
		COPY_EXISTING	~LISTSPLL.2DA~	override
			CLEAR_ARRAY	~IDX_LISTSPLL~
			READ_2DA_ENTRIES_NOW	~IDX_LISTSPLL~	9
		BUT_ONLY
	END

	//	v1.0
	DEFINE_PATCH_FUNCTION	IWD2_CRE_SPELL
		INT_VAR
			num = 1
			index = ~-1~
			forcelevel = 0
		STR_VAR
			class = ~~
			resource = ~~
	BEGIN
		TO_UPPER	resource
		TO_LOWER	class
		PATCH_MATCH	~%class%~
		WITH	~bard~			~brd~	BEGIN	SET	col = 1	TEXT_SPRINT	pre ~ba~	SET	idx_off = 0x3ba
			END	~cleric~		~clr~	BEGIN	SET	col = 2	TEXT_SPRINT	pre ~cl~	SET	idx_off = 0x3de 
			END	~druid~			~drd~	BEGIN	SET	col = 3	TEXT_SPRINT	pre ~dr~	SET	idx_off = 0x402
			END	~paladin~		~pal~	BEGIN	SET	col = 4	TEXT_SPRINT	pre ~pa~	SET	idx_off = 0x426
			END	~ranger~		~rgr~	BEGIN	SET	col = 5	TEXT_SPRINT	pre ~ra~	SET	idx_off = 0x44a
			END	~sorcerer~	~sor~	BEGIN	SET	col = 6	TEXT_SPRINT	pre ~so~	SET	idx_off = 0x46e
			END	~wizard~		~wiz~	BEGIN	SET	col = 7	TEXT_SPRINT	pre ~wi~	SET	idx_off = 0x492
			END	~domain~		~dmn~	BEGIN	SET	col = 8	TEXT_SPRINT	pre ~do~	SET	idx_off = 0x5b2
			END	DEFAULT	col = 0
		END
		PATCH_IF	col = 0	BEGIN
			PATCH_WARN	~Invalid Class (%class%) - "bard","BRD","cleric","CLR","druid","DRD","paladin","PAL","ranger","RGR","sorcerer","SOR","wizard","WIZ","domain","DMN"~
		END	ELSE	BEGIN
			PATCH_MATCH	index	WITH
				ANY index > IDX_LISTSPLL	BEGIN
					PATCH_WARN	~Invalid Spell - index not listed in LISTSPLL.2da~
					SET	index = ~-1~
				END	~-1~	BEGIN
					FOR	(i = 0; i < IDX_LISTSPLL; ++i) BEGIN
						READ_2DA_ENTRY_FORMER	~IDX_LISTSPLL~	i 8	entry
						TO_UPPER	entry
						PATCH_IF	~%entry%~ STRING_EQUAL ~%resource%~	BEGIN
							PATCH_IF	col = 8	BEGIN
								SET	level = forcelevel
								SET	index = i //- 1
							END	ELSE	BEGIN
								READ_2DA_ENTRY_FORMER	~IDX_LISTSPLL~	i col	level
								PATCH_IF	level > 0	BEGIN
									SET	index = i //- 1
								END	ELSE	BEGIN
									PATCH_IF	forcelevel BEGIN
										SET	index = i //- 1
										SET	level = forcelevel
									END	ELSE	BEGIN
										SET	index = ~-1~
									END
								END
							END
							SET	i = IDX_LISTSPLL
						END
					END
				END	DEFAULT
					READ_2DA_ENTRY_FORMER	~IDX_LISTSPLL~	index col	level
					PATCH_IF	level = 0	BEGIN
						SET	index = ~-1~
					END
			END
			PATCH_IF	index = ~-1~	BEGIN
				PATCH_WARN	~Spell (%resource%) not available to (%class%), check (LISTSPLL.2da).~
			END	ELSE	BEGIN
				READ_ASCII	0	sig	(8)
				PATCH_IF	~%sig%~	STRING_EQUAL	~CRE V2.2~	BEGIN
					SET	lvl = level - 1
					TEXT_SPRINT	splnum ~%pre%_%lvl%_num~
					TEXT_SPRINT	sploff ~%pre%_%lvl%_off~
					LPF	IWD2_CRE_REINDEX	RET
						ba_0_off ba_0_num ba_1_off ba_1_num ba_2_off ba_2_num ba_3_off ba_3_num ba_4_off ba_4_num ba_5_off ba_5_num ba_6_off ba_6_num ba_7_off ba_7_num ba_8_off ba_8_num
						cl_0_off cl_0_num cl_1_off cl_1_num cl_2_off cl_2_num cl_3_off cl_3_num cl_4_off cl_4_num cl_5_off cl_5_num cl_6_off cl_6_num cl_7_off cl_7_num cl_8_off cl_8_num
						dr_0_off dr_0_num dr_1_off dr_1_num dr_2_off dr_2_num dr_3_off dr_3_num dr_4_off dr_4_num dr_5_off dr_5_num dr_6_off dr_6_num dr_7_off dr_7_num dr_8_off dr_8_num
						pa_0_off pa_0_num pa_1_off pa_1_num pa_2_off pa_2_num pa_3_off pa_3_num pa_4_off pa_4_num pa_5_off pa_5_num pa_6_off pa_6_num pa_7_off pa_7_num pa_8_off pa_8_num
						ra_0_off ra_0_num ra_1_off ra_1_num ra_2_off ra_2_num ra_3_off ra_3_num ra_4_off ra_4_num ra_5_off ra_5_num ra_6_off ra_6_num ra_7_off ra_7_num ra_8_off ra_8_num
						so_0_off so_0_num so_1_off so_1_num so_2_off so_2_num so_3_off so_3_num so_4_off so_4_num so_5_off so_5_num so_6_off so_6_num so_7_off so_7_num so_8_off so_8_num
						wi_0_off wi_0_num wi_1_off wi_1_num wi_2_off wi_2_num wi_3_off wi_3_num wi_4_off wi_4_num wi_5_off wi_5_num wi_6_off wi_6_num wi_7_off wi_7_num wi_8_off wi_8_num
						do_0_off do_0_num do_1_off do_1_num do_2_off do_2_num do_3_off do_3_num do_4_off do_4_num do_5_off do_5_num do_6_off do_6_num do_7_off do_7_num do_8_off do_8_num
						ab_off ab_num sng_off shp_off	slt_off	itm_off	fx_off	END
					SET	splnum = EVAL ~%splnum%~
					SET	sploff = EVAL ~%sploff%~
					SET	spl_add = 1
					FOR	(i = 0; i < splnum; ++i)	BEGIN
						READ_LONG	(sploff + i * 0x10)	ability
						PATCH_IF	ability = index	BEGIN
							READ_LONG	(sploff + i * 0x10 + 0x4) kn_num
							READ_LONG	(sploff + i * 0x10 + 0x8) mz_num
							PATCH_IF	(num <= ~-2~)	BEGIN
								DELETE_BYTES	(sploff + i * 0x10)	0x10
								SET	spl_add = ~-1~
							END	ELSE	BEGIN
								PATCH_IF	(num = ~-1~) BEGIN
									WRITE_LONG	(sploff + i * 0x10 + 0x4)	0
									WRITE_LONG	(sploff + i * 0x10 + 0x8)	0
								END	ELSE	BEGIN
									WRITE_LONG	(sploff + i * 0x10 + 0x4)	(THIS + num)
									WRITE_LONG	(sploff + i * 0x10 + 0x8)	(THIS + num)
								END
								SET spl_add = 0
							END
						END
					END
					PATCH_IF	spl_add = 1	AND num >= 0 BEGIN
						INSERT_BYTES	(sploff + splnum * 0x10)	0x10
						WRITE_LONG		(sploff + splnum * 0x10)	index
						WRITE_LONG		(sploff + splnum * 0x10 + 0x4)	num
						WRITE_LONG		(sploff + splnum * 0x10 + 0x8)	num
					END
					SET	update = 0
					PATCH_IF	spl_add	!= 0	BEGIN
						DEFINE_ASSOCIATIVE_ARRAY	offsets	BEGIN	0x3ba => 0x4b6	0x3de => 0x4da	0x402 => 0x4fe	0x426 => 0x522	0x44a => 0x546	0x46e => 0x56a	0x492 => 0x58e	0x5b2 => 0x5d6	END
						PHP_EACH	offsets AS	offset => count	BEGIN
							FOR	(i = 0; i < 9; ++i)	BEGIN
								PATCH_IF	update = 0	BEGIN
									PATCH_IF	idx_off + (level - 1) * 4 = offset + i * 4	BEGIN
										SET	update = 1
										WRITE_LONG	(count + i * 4)	(THIS + spl_add)
									END
								END	ELSE	BEGIN
									WRITE_LONG	(offset + i * 4) (THIS + 0x10 * spl_add)
								END
							END
						END
						WRITE_LONG	0x5fa (THIS + 0x10 * spl_add)	//	Abilities offset
						WRITE_LONG	0x602	(THIS + 0x10 * spl_add)	//	Songs offset
						WRITE_LONG	0x60a	(THIS + 0x10 * spl_add)	//	Shapes offset
						WRITE_LONG	0x612	(THIS + 0x10 * spl_add)	//	Item Slots offset
						WRITE_LONG	0x616	(THIS + 0x10 * spl_add)	//	Items offset
						WRITE_LONG	0x61e	(THIS + 0x10 * spl_add)	//	Effects offset
					END
				END
			END
		END
	END



	//	v1.0
	DEFINE_PATCH_FUNCTION	IWD2_REMOVE_SPELLS_KNOWN
		STR_VAR
			level = ~0~
			class = ~~
	BEGIN
		TO_LOWER	class
		READ_ASCII	0	sig	(8)
		PATCH_IF	~%sig%~	STRING_EQUAL	~CRE V2.2~	BEGIN
			SET	lvl = level - 1
			TEXT_SPRINT	splnum ~%pre%_%lvl%_num~
			TEXT_SPRINT	sploff ~%pre%_%lvl%_off~
			LPF	IWD2_CRE_REINDEX	RET
				ba_0_off ba_0_num ba_1_off ba_1_num ba_2_off ba_2_num ba_3_off ba_3_num ba_4_off ba_4_num ba_5_off ba_5_num ba_6_off ba_6_num ba_7_off ba_7_num ba_8_off ba_8_num
				cl_0_off cl_0_num cl_1_off cl_1_num cl_2_off cl_2_num cl_3_off cl_3_num cl_4_off cl_4_num cl_5_off cl_5_num cl_6_off cl_6_num cl_7_off cl_7_num cl_8_off cl_8_num
				dr_0_off dr_0_num dr_1_off dr_1_num dr_2_off dr_2_num dr_3_off dr_3_num dr_4_off dr_4_num dr_5_off dr_5_num dr_6_off dr_6_num dr_7_off dr_7_num dr_8_off dr_8_num
				pa_0_off pa_0_num pa_1_off pa_1_num pa_2_off pa_2_num pa_3_off pa_3_num pa_4_off pa_4_num pa_5_off pa_5_num pa_6_off pa_6_num pa_7_off pa_7_num pa_8_off pa_8_num
				ra_0_off ra_0_num ra_1_off ra_1_num ra_2_off ra_2_num ra_3_off ra_3_num ra_4_off ra_4_num ra_5_off ra_5_num ra_6_off ra_6_num ra_7_off ra_7_num ra_8_off ra_8_num
				so_0_off so_0_num so_1_off so_1_num so_2_off so_2_num so_3_off so_3_num so_4_off so_4_num so_5_off so_5_num so_6_off so_6_num so_7_off so_7_num so_8_off so_8_num
				wi_0_off wi_0_num wi_1_off wi_1_num wi_2_off wi_2_num wi_3_off wi_3_num wi_4_off wi_4_num wi_5_off wi_5_num wi_6_off wi_6_num wi_7_off wi_7_num wi_8_off wi_8_num
				do_0_off do_0_num do_1_off do_1_num do_2_off do_2_num do_3_off do_3_num do_4_off do_4_num do_5_off do_5_num do_6_off do_6_num do_7_off do_7_num do_8_off do_8_num
				ab_off ab_num sng_off shp_off	slt_off	itm_off	fx_off	END
			DEFINE_ASSOCIATIVE_ARRAY	classes	BEGIN
				~bard~			, 0x3ba , 0x4b6	=> ~ba~
				~cleric~		, 0x3de , 0x4da => ~cl~ 
				~druid~			, 0x402 , 0x4fe => ~dr~
				~paladin~		, 0x426 , 0x522 => ~pa~ 
				~ranger~		, 0x44a , 0x546 => ~ra~
				~sorcerer~	, 0x46e , 0x56a => ~so~
				~wizard~		, 0x492 , 0x58e => ~wi~
				~domain~		, 0x5b2 , 0x5d6 => ~do~
			END
			SET	offset = 0
			PHP_EACH	classes	AS	label => pre	BEGIN
				FOR	(i = 1; i < 10; ++i)	BEGIN
					SET	lvl = i - 1
					WRITE_LONG	(label_1 + lvl * 4)	(THIS - offset * 0x10)
					PATCH_IF	! ~%class%~	STRING_CONTAINS_REGEXP ~%label%~	BEGIN
						PATCH_IF	(! ~%level%~	STRING_CONTAINS_REGEXP ~[%i%0]~)	BEGIN
							DELETE_BYTES	($~%pre%~(~%lvl%~~off~) - offset * 0x10) 	($~%pre%~(~%lvl%~~num~) * 0x10)
							WRITE_LONG	(label_2 + lvl * 4) 0
							SET	offset += $~%pre%~(~%lvl%~~num~)
						END
					END
				END
			END
			WRITE_LONG	0x5fa (THIS - offset * 0x10)	//	Abilities offset
			WRITE_LONG	0x602	(THIS - offset * 0x10)	//	Songs offset
			WRITE_LONG	0x60a	(THIS - offset * 0x10)	//	Shapes offset
			WRITE_LONG	0x612	(THIS - offset * 0x10)	//	Item Slots offset
			WRITE_LONG	0x616	(THIS - offset * 0x10)	//	Items offset
			WRITE_LONG	0x61e	(THIS - offset * 0x10)	//	Effects offset
		END
	END

	DEFINE_PATCH_FUNCTION	GIVE_CORRECT_DIVINE_SPELLS
	BEGIN
		READ_BYTE 0x8D theclericlevel
		READ_BYTE 0x8E thedruidlevel
		READ_BYTE 0x91 thepaladinlevel
		READ_BYTE 0x92 therangerlevel
		READ_BYTE 0x38F thealignment
		maxclericspelllevel = 0
		maxdruidspelllevel = 0
		maxpaladinspelllevel = 0
		maxrangerspelllevel = 0
		PATCH_IF theclericlevel > 0 BEGIN
			INNER_ACTION BEGIN
				COPY_EXISTING ~mxsplclr.2da~ ~override~
					COUNT_2DA_COLS numcols
					READ_2DA_ENTRY 0 0 numcols firstspellcastinglevel
					row = theclericlevel - firstspellcastinglevel
					PATCH_IF row >= 0 BEGIN
						FOR (i = 1; i < numcols; ++i) BEGIN
							READ_2DA_ENTRY row i numcols thenumspells
							PATCH_IF thenumspells > 0 BEGIN
								maxclericspelllevel = i
							END
						END
					END
					BUT_ONLY_IF_IT_CHANGES
			END
		END
		PATCH_IF thedruidlevel > 0 BEGIN
			INNER_ACTION BEGIN
				COPY_EXISTING ~mxspldrd.2da~ ~override~
					COUNT_2DA_COLS numcols
					READ_2DA_ENTRY 0 0 numcols firstspellcastinglevel
					row = thedruidlevel - firstspellcastinglevel
					PATCH_IF row >= 0 BEGIN
						FOR (i = 1; i < numcols; ++i) BEGIN
							READ_2DA_ENTRY row i numcols thenumspells
							PATCH_IF thenumspells > 0 BEGIN
								maxdruidspelllevel = i
							END
						END
					END
					BUT_ONLY_IF_IT_CHANGES
			END
		END
		PATCH_IF thepaladinlevel > 0 BEGIN
			INNER_ACTION BEGIN
				COPY_EXISTING ~mxsplpal.2da~ ~override~
					COUNT_2DA_COLS numcols
					READ_2DA_ENTRY 0 0 numcols firstspellcastinglevel
					row = thepaladinlevel - firstspellcastinglevel
					PATCH_IF row >= 0 BEGIN
						FOR (i = 1; i < numcols; ++i) BEGIN
							READ_2DA_ENTRY row i numcols thenumspells
							PATCH_IF thenumspells > 0 BEGIN
								maxpaladinspelllevel = i
							END
						END
					END
					BUT_ONLY_IF_IT_CHANGES
			END
		END
		PATCH_IF therangerlevel > 0 BEGIN
			INNER_ACTION BEGIN
				COPY_EXISTING ~mxsplrgr.2da~ ~override~
					COUNT_2DA_COLS numcols
					READ_2DA_ENTRY 0 0 numcols firstspellcastinglevel
					row = therangerlevel - firstspellcastinglevel
					PATCH_IF row >= 0 BEGIN
						FOR (i = 1; i < numcols; ++i) BEGIN
							READ_2DA_ENTRY row i numcols thenumspells
							PATCH_IF thenumspells > 0 BEGIN
								maxrangerspelllevel = i
							END
						END
					END
					BUT_ONLY_IF_IT_CHANGES
			END
		END
		FOR	(i = 0; i < IDX_LISTSPLL; ++i) BEGIN
			READ_2DA_ENTRY_FORMER	~IDX_LISTSPLL~	i 2	currentclericspelllevel
			READ_2DA_ENTRY_FORMER	~IDX_LISTSPLL~	i 3	currentdruidspelllevel
			READ_2DA_ENTRY_FORMER	~IDX_LISTSPLL~	i 4	currentpaladinspelllevel
			READ_2DA_ENTRY_FORMER	~IDX_LISTSPLL~	i 5	currentrangerspelllevel
			READ_2DA_ENTRY_FORMER	~IDX_LISTSPLL~	i 8	resource
			matchesalignment = 1
			PATCH_IF FILE_EXISTS_IN_GAME ~%resource%.spl~ BEGIN
				INNER_ACTION BEGIN
					COPY_EXISTING ~%resource%.spl~ ~override~
						READ_LONG 0x1E theunusabilityflags
						PATCH_IF ((theunusabilityflags BAND 0x00000001) > 0) AND ((thealignment BAND 0x00000030) > 0) OR ((theunusabilityflags BAND 0x00000002) > 0) AND ((thealignment BAND 0x00000003) > 0) OR ((theunusabilityflags BAND 0x00000004) > 0) AND ((thealignment BAND 0x00000001) > 0) OR ((theunusabilityflags BAND 0x00000008) > 0) AND ((thealignment BAND 0x00000002) > 0) OR ((theunusabilityflags BAND 0x00000010) > 0) AND ((thealignment BAND 0x00000010) > 0) OR ((theunusabilityflags BAND 0x00000020) > 0) AND ((thealignment BAND 0x00000020) > 0) BEGIN
							matchesalignment = 0
						END
						BUT_ONLY_IF_IT_CHANGES
				END
				PATCH_IF matchesalignment = 1 BEGIN
					PATCH_IF currentclericspelllevel > 0 AND currentclericspelllevel <= maxclericspelllevel BEGIN
						LPF	IWD2_CRE_SPELL INT_VAR num=0 STR_VAR class=~cleric~ resource= EVAL ~%resource%~ END
					END
					PATCH_IF currentdruidspelllevel > 0 AND currentdruidspelllevel <= maxdruidspelllevel BEGIN
						LPF	IWD2_CRE_SPELL INT_VAR num=0 STR_VAR class=~druid~ resource= EVAL ~%resource%~ END
					END
					PATCH_IF currentpaladinspelllevel > 0 AND currentpaladinspelllevel <= maxpaladinspelllevel BEGIN
						LPF	IWD2_CRE_SPELL INT_VAR num=0 STR_VAR class=~paladin~ resource= EVAL ~%resource%~ END
					END
					PATCH_IF currentrangerspelllevel > 0 AND currentrangerspelllevel <= maxrangerspelllevel BEGIN
						LPF	IWD2_CRE_SPELL INT_VAR num=0 STR_VAR class=~ranger~ resource= EVAL ~%resource%~ END
					END
				END
			END
		END
	END


	//	v1.0
	DEFINE_PATCH_FUNCTION	IWD2_REMOVE_SPELLS_MEMORIZED
		STR_VAR
			level = ~0~
			class = ~~
	BEGIN
		TO_LOWER	class
		READ_ASCII	0	sig	(8)
		PATCH_IF	~%sig%~	STRING_EQUAL	~CRE V2.2~	BEGIN
			SET	lvl = level - 1
			TEXT_SPRINT	splnum ~%pre%_%lvl%_num~
			TEXT_SPRINT	sploff ~%pre%_%lvl%_off~
			LPF	IWD2_CRE_REINDEX	RET
				ba_0_off ba_0_num ba_1_off ba_1_num ba_2_off ba_2_num ba_3_off ba_3_num ba_4_off ba_4_num ba_5_off ba_5_num ba_6_off ba_6_num ba_7_off ba_7_num ba_8_off ba_8_num
				cl_0_off cl_0_num cl_1_off cl_1_num cl_2_off cl_2_num cl_3_off cl_3_num cl_4_off cl_4_num cl_5_off cl_5_num cl_6_off cl_6_num cl_7_off cl_7_num cl_8_off cl_8_num
				dr_0_off dr_0_num dr_1_off dr_1_num dr_2_off dr_2_num dr_3_off dr_3_num dr_4_off dr_4_num dr_5_off dr_5_num dr_6_off dr_6_num dr_7_off dr_7_num dr_8_off dr_8_num
				pa_0_off pa_0_num pa_1_off pa_1_num pa_2_off pa_2_num pa_3_off pa_3_num pa_4_off pa_4_num pa_5_off pa_5_num pa_6_off pa_6_num pa_7_off pa_7_num pa_8_off pa_8_num
				ra_0_off ra_0_num ra_1_off ra_1_num ra_2_off ra_2_num ra_3_off ra_3_num ra_4_off ra_4_num ra_5_off ra_5_num ra_6_off ra_6_num ra_7_off ra_7_num ra_8_off ra_8_num
				so_0_off so_0_num so_1_off so_1_num so_2_off so_2_num so_3_off so_3_num so_4_off so_4_num so_5_off so_5_num so_6_off so_6_num so_7_off so_7_num so_8_off so_8_num
				wi_0_off wi_0_num wi_1_off wi_1_num wi_2_off wi_2_num wi_3_off wi_3_num wi_4_off wi_4_num wi_5_off wi_5_num wi_6_off wi_6_num wi_7_off wi_7_num wi_8_off wi_8_num
				do_0_off do_0_num do_1_off do_1_num do_2_off do_2_num do_3_off do_3_num do_4_off do_4_num do_5_off do_5_num do_6_off do_6_num do_7_off do_7_num do_8_off do_8_num
				ab_off ab_num sng_off shp_off	slt_off	itm_off	fx_off	END
			DEFINE_ASSOCIATIVE_ARRAY	classes	BEGIN
				~bard~ => ~ba~ 	~cleric~ => ~cl~ 	~druid~ => ~dr~ 	~paladin~ => ~pa~ 	~ranger~ => ~ra~ 	~sorcerer~ => ~so~ 	~wizard~ => ~wi~ 	~domain~ => ~do~
			END
			PHP_EACH	classes AS	label => pre	BEGIN
				PATCH_IF	! ~%class%~	STRING_CONTAINS_REGEXP ~%label%~	BEGIN
					FOR	(i = 1; i < 10; ++i)	BEGIN	SET	lvl = i - 1
						PATCH_IF	(! ~%level%~	STRING_CONTAINS_REGEXP ~[%i%0]~)	BEGIN
							FOR (j = 0; j < $~%pre%~(~%lvl%~~num~); ++j)	BEGIN
								WRITE_LONG	($~%pre%~(~%lvl%~~off~) + j * 0x10 + 0x4) 	0
								WRITE_LONG	($~%pre%~(~%lvl%~~off~) + j * 0x10 + 0x8) 	0
							END
						END
					END
				END
			END
		END
	END

	//	v1.0
	DEFINE_PATCH_FUNCTION	IWD2_CRE_ABILITY
		INT_VAR
			num = 1
			index = ~-1~
		STR_VAR
			resource = ~~
	BEGIN
		TO_UPPER resource
		PATCH_MATCH	index	WITH
			ANY index > IDX_LISTINNT	BEGIN	
				PATCH_WARN	~Invalid Ability - index not listed in LISTINNT.2da~
				SET	index = ~-1~
			END	~-1~	BEGIN
				FOR	(i = 1; i < IDX_LISTINNT; ++i) BEGIN
					READ_2DA_ENTRY_FORMER	~IDX_LISTINNT~	i 1	entry
					TO_UPPER	entry
					PATCH_IF	~%entry%~ STRING_EQUAL ~%resource%~	BEGIN
						SET	index = i - 1
						SET	i = IDX_LISTINNT
					END
				END
			END	DEFAULT
		END
		PATCH_IF	index = ~-1~	BEGIN
			PATCH_WARN	~Invalid Ability (%resource%) - not listed in LISTINNT.2da~
		END	ELSE	BEGIN
			READ_ASCII	0	sig	(8)
			PATCH_IF	~%sig%~	STRING_EQUAL	~CRE V2.2~	BEGIN
				LPF	IWD2_CRE_REINDEX	RET	ab_off ab_num sng_off shp_off	slt_off	itm_off	fx_off	END
				SET	ab_add = 0
				FOR	(i = 0; i < ab_num; ++i)	BEGIN
					READ_LONG	(ab_off + i * 0x10)	ability
					PATCH_IF	ability = index	BEGIN
						READ_LONG	(ab_off + i * 0x10 + 0x4) kn_num
						READ_LONG	(ab_off + i * 0x10 + 0x8) mz_num
						PATCH_IF	(kn_num + num) <= 0 OR (num = 0)	BEGIN
							DELETE_BYTES	(ab_off + i * 0x10)	0x10
							SET	ab_add = ~-1~
						END	ELSE	BEGIN
							WRITE_LONG	(ab_off + i * 0x10 + 0x4)	(THIS + num)
							PATCH_IF	mz_num + num <= 0	BEGIN
								WRITE_LONG	(ab_off + i * 0x10 + 0x8)	0
							END	ELSE	BEGIN
								WRITE_LONG	(ab_off + i * 0x10 + 0x8)	(THIS + num)
							END
						END
					END
				END
				PATCH_IF	ab_add = 0	AND num > 0 BEGIN
					INSERT_BYTES	(ab_off + ab_num * 0x10)	0x10
					WRITE_LONG		(ab_off + ab_num * 0x10)	index
					WRITE_LONG		(ab_off + ab_num * 0x10 + 0x4)	num
					WRITE_LONG		(ab_off + ab_num * 0x10 + 0x8)	num
					SET	ab_add = 1
				END
				PATCH_IF	ab_add	!= 0	BEGIN
					WRITE_LONG	0x5fe (THIS + ab_add)					//	Abilities count
					WRITE_LONG	0x602	(THIS + 0x10 * ab_add)	//	Songs offset
					WRITE_LONG	0x60a	(THIS + 0x10 * ab_add)	//	Shapes offset
					WRITE_LONG	0x612	(THIS + 0x10 * ab_add)	//	Item Slots offset
					WRITE_LONG	0x616	(THIS + 0x10 * ab_add)	//	Items offset
					WRITE_LONG	0x61e	(THIS + 0x10 * ab_add)	//	Effects offset
				END
			END
		END
	END

	//	v1.0
	DEFINE_PATCH_FUNCTION	IWD2_ADD_CRE_EFFECT
		INT_VAR
			opcode = 0
			timing = 0
			target = 0
			parameter1 = 0
			parameter2 = 0
			parameter3 = 0
			parameter4 = 0
	//		parameter5 = 0
	//		time_applied = 0	//	EE-only
			power = 0
			resist_dispel = 0
			duration = 0
			probability1 = 100
			probability2 = 0
			dicenumber = 0
			dicesize = 0
			savingthrow = 0
			savebonus = 0
			school = 0
			special = 0
	//		internal = 0
			lowestefflvl = 0
			highestefflvl = 0
			casterx = ~-1~
			castery = ~-1~
			targetx = ~-1~
			targety = ~-1~
			restype = 0
			sourceflags = 0
			projectile = 0
			sourceslot = ~-1~
			casterlvl = 0
	//		internalflags = 0
			sectype = 0
			insert_point = ~-1~
		STR_VAR
			resource = ~~
			resource2 = ~~
			resource3 = ~~
			effsource = ~~
			effvar = ~~
	BEGIN
		READ_ASCII	0	sig	(8)
		PATCH_IF	~%sig%~	STRING_EQUAL	~CRE V2.2~	BEGIN
			LPF	IWD2_CRE_REINDEX	RET	fx_off	fx_num	END
			READ_BYTE	0x33	fx_ver
			PATCH_IF	fx_ver	= 0 	BEGIN
				PATCH_IF	fx_num = 0	BEGIN
					WRITE_BYTE	0x33	1
				END	ELSE	BEGIN
					PATCH_FAIL	~Needs converting to V2 effects.~
				END
			END
			PATCH_IF	(insert_point > fx_num) OR (insert_point < 0)	BEGIN
				SET	insert_point = fx_num
			END
			INSERT_BYTES	(fx_off + insert_point * 0x108)	0x108
			WRITE_ASCII		(fx_off + insert_point * 0x108)	~EFF V2.0~
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x8)		opcode
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0xc)		target
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x10)	power
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x14)	parameter1
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x18)	parameter2
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x1c)	timing
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x20)	duration
			WRITE_SHORT		(fx_off + insert_point * 0x108 + 0x24)	probability1
			WRITE_SHORT		(fx_off + insert_point * 0x108 + 0x26)	probability2
			WRITE_ASCIIE	(fx_off + insert_point * 0x108 + 0x28)	~%resource%~	#8
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x30)	dicenumber
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x34)	dicesize
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x38)	savingthrow
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x3c)	savebonus
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x40)	special
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x44)	school
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x48)	sectype
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x4c)	lowestefflvl
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x50)	highestefflvl
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x54)	resist_dispel
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x58)	parameter3
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x5c)	parameter4
	//		WRITE_LONG		(fx_off + insert_point * 0x108 + 0x60)	parameter5
	//		WRITE_LONG		(fx_off + insert_point * 0x108 + 0x64)	time_applied
			WRITE_ASCIIE	(fx_off + insert_point * 0x108 + 0x68)	~%resource2%~	#8
			WRITE_ASCIIE	(fx_off + insert_point * 0x108 + 0x70)	~%resource3%~	#8
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x78)	casterx
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x7c)	castery
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x80)	targetx
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x84)	targety
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x88)	restype
			WRITE_ASCIIE	(fx_off + insert_point * 0x108 + 0x8c)	~%effsource%~	#8
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x94)	sourceflags
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x98)	projectile
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0x9c)	sourceslot
			WRITE_ASCIIE	(fx_off + insert_point * 0x108 + 0xa0)	~%effvar%~	#32
			WRITE_LONG		(fx_off + insert_point * 0x108 + 0xc0)	casterlvl
	//		WRITE_LONG		(fx_off + insert_point * 0x108 + 0xc4)	internalflags
			WRITE_LONG	0x622 (THIS + 1)
		END
	END

	//	v1.0
	DEFINE_PATCH_FUNCTION	IWD2_ADD_CRE_ITEM
		INT_VAR
			cq1 = 0
			cq2 = 0
			cq3 = 0
			equip = 1
			ability = 0
		STR_VAR
			mode = ~~
			item = ~~
			flags = ~~
			slot = ~~
	BEGIN
		READ_ASCII	0	sig	(8)
		PATCH_IF	~%sig%~	STRING_EQUAL	~CRE V2.2~	BEGIN
			LPF	IWD2_CRE_REINDEX	RET	slt_off	itm_off	itm_num	fx_off	END
			SET	flag = 0
			PATCH_IF	! ~%flags%~	STRING_CONTAINS_REGEXP	~identified~	BEGIN	SET	flag |= 1	END
			PATCH_IF	! ~%flags%~	STRING_CONTAINS_REGEXP	~unstealable~	BEGIN	SET	flag |= 2	END
			PATCH_IF	! ~%flags%~	STRING_CONTAINS_REGEXP	~stolen~			BEGIN	SET	flag |= 4	END
			PATCH_IF	! ~%flags%~	STRING_CONTAINS_REGEXP	~undroppable~	BEGIN	SET	flag |= 8	END
			TO_LOWER	slot
			TO_LOWER	mode
			SET	itm_add = 1
			INNER_PATCH	~%slot%~	BEGIN
				REPLACE_TEXTUALLY	~[ %TAB%%WNL%%MNL%%LNL%]+~	~ ~
				COUNT_2DA_COLS	cols
				READ_2DA_ENTRIES_NOW	~READ_ADD_CRE_ITEM~	cols
			END
			SET	wpn_slot = ~-1~	FOR	(i = 9; i < 16; i+=2)		BEGIN	READ_SHORT	(slt_off + i * 0x2)	index	PATCH_IF index = 65535	BEGIN	SET	wpn_slot = i	SET	i = 16	END	END
			SET	shd_slot = ~-1~	FOR	(i = 10; i < 17; i+=2)	BEGIN	READ_SHORT	(slt_off + i * 0x2)	index	PATCH_IF index = 65535	BEGIN	SET	shd_slot = i	SET	i = 17	END	END
			SET	inv_slot = ~-1~	FOR	(i = 25; i < 49; ++i)		BEGIN	READ_SHORT	(slt_off + i * 0x2)	index	PATCH_IF index = 65535	BEGIN	SET	inv_slot = i	SET	i = 49	END	END
			SET	qvr_slot = ~-1~	FOR	(i = 17; i < 20; ++i)		BEGIN	READ_SHORT	(slt_off + i * 0x2)	index	PATCH_IF index = 65535	BEGIN	SET	qvr_slot = i	SET	i = 20	END	END
			SET	qit_slot = ~-1~	FOR	(i = 22; i < 25; ++i)		BEGIN	READ_SHORT	(slt_off + i * 0x2)	index	PATCH_IF index = 65535	BEGIN	SET	qit_slot = i	SET	i = 25	END	END
			SET	rng_slot = ~-1~		FOR	(i = 4; i < 6; ++i)		BEGIN	READ_SHORT	(slt_off + i * 0x2)	index	PATCH_IF index = 65535	BEGIN	SET	rng_slot = i	SET	i = 6		END	END
			FOR	(i = 0; i < cols; ++i)	BEGIN
				READ_2DA_ENTRY_FORMER	~READ_ADD_CRE_ITEM~ 0 i slot
				PATCH_MATCH	~%slot%~
				WITH	~helmet~	BEGIN	SET	slot = 0		END	~armor~		BEGIN	SET	slot = 1		END	~shield~	BEGIN	SET	slot = 2		END	~gloves~	BEGIN	SET	slot = 3
					END	~lring~		BEGIN	SET	slot = 4		END	~rring~		BEGIN	SET	slot = 5		END	~amulet~	BEGIN	SET	slot = 6		END	~belt~		BEGIN	SET	slot = 7
					END	~boots~		BEGIN	SET	slot = 8		END	~ring~		BEGIN	SET	slot = 53		END	~inv~			BEGIN	SET	slot = 54		
					END	~weapon1~	BEGIN	SET	slot = 9		END	~shield1~	BEGIN	SET	slot = 10		END	~weapon2~	BEGIN	SET	slot = 11		END	~shield2~	BEGIN	SET	slot = 12
					END	~weapon3~	BEGIN	SET	slot = 13		END	~shield3~	BEGIN	SET	slot = 14		END	~weapon4~	BEGIN	SET	slot = 15		END	~shield4~	BEGIN	SET	slot = 16
					END	~quiver1~	BEGIN	SET	slot = 17		END	~quiver2~	BEGIN	SET	slot = 18		END	~quiver3~	BEGIN	SET	slot = 19		END	~quiver4~	BEGIN	SET	slot = 20
					END	~cloak~		BEGIN	SET	slot = 21		END	~qitem1~	BEGIN	SET	slot = 22		END	~qitem2~	BEGIN	SET	slot = 23		END	~qitem3~	BEGIN	SET	slot = 24
					END	~inv1~		BEGIN	SET	slot = 25		END	~inv2~		BEGIN	SET	slot = 26		END	~inv3~		BEGIN	SET	slot = 27		END	~inv4~		BEGIN	SET	slot = 28
					END	~inv5~		BEGIN	SET	slot = 29		END	~inv6~		BEGIN	SET	slot = 30		END	~inv7~		BEGIN	SET	slot = 31		END	~inv8~		BEGIN	SET	slot = 32
					END	~inv9~		BEGIN	SET	slot = 33		END	~inv10~		BEGIN	SET	slot = 34		END	~inv11~		BEGIN	SET	slot = 35		END	~inv12~		BEGIN	SET	slot = 36
					END	~inv13~		BEGIN	SET	slot = 37		END	~inv14~		BEGIN	SET	slot = 38		END	~inv15~		BEGIN	SET	slot = 39		END	~inv16~		BEGIN	SET	slot = 40
					END	~inv17~		BEGIN	SET	slot = 41		END	~inv18~		BEGIN	SET	slot = 42		END	~inv19~		BEGIN	SET	slot = 43		END	~inv20~		BEGIN	SET	slot = 44
					END	~inv21~		BEGIN	SET	slot = 45		END	~inv22~		BEGIN	SET	slot = 46		END	~inv23~		BEGIN	SET	slot = 47		END	~inv24~		BEGIN	SET	slot = 48
					END	~magic~		BEGIN	SET	slot = 49		END	~weapon~	BEGIN	SET	slot = 50		END	~quiver~	BEGIN	SET	slot = 51		END	~qitem~		BEGIN	SET	slot = 52
					END	DEFAULT	SET	slot = ~-1~
				END
				PATCH_IF	slot = ~-1~	BEGIN
					SET	i = cols
					PATCH_IF	inv_slot != ~-1~	BEGIN
						WRITE_SHORT	(slt_off + inv_slot * 0x2)	itm_num
					END
				END	ELSE	BEGIN
					PATCH_MATCH	slot
					WITH	2	WHEN shd_slot != ~-1~	BEGIN	slot = shd_slot
						END	50 WHEN wpn_slot != ~-1~	BEGIN	slot = wpn_slot
						END	51 WHEN qvr_slot != ~-1~	BEGIN	slot = qvr_slot
						END	52 WHEN qit_slot != ~-1~	BEGIN	slot = qit_slot
						END	53 WHEN rng_slot != ~-1~	BEGIN	slot = rng_slot
						END	54 WHEN inv_slot != ~-1~	BEGIN	slot = inv_slot
						END	DEFAULT
							READ_SHORT	(slt_off + slot * 0x2)	value
							PATCH_IF	value != 65535	BEGIN
								PATCH_IF	~%mode%~	STRING_EQUAL	~move~	BEGIN
									WRITE_SHORT	(slt_off + inv_slot * 0x2)	value
									SET	i = cols
								END
								PATCH_IF	~%mode%~	STRING_EQUAL	~replace~	BEGIN
									SET	i = cols
									SET	itm_num = value
									SET	itm_add = 0
								END
							END
					END
				END
			END
			PATCH_IF	slot = ~-1~	BEGIN
				PATCH_WARN	~No available inventory slots, item not added.~
			END	ELSE	BEGIN
				WRITE_SHORT	(slt_off + slot * 0x2)	itm_num
				PATCH_IF	itm_add	BEGIN
					INSERT_BYTES	(itm_off + itm_num * 0x14)	0x14
				END
				WRITE_ASCIIE	(itm_off + itm_num * 0x14)	~%item%~	#8
				WRITE_SHORT		(itm_off + itm_num * 0x14 + 0xa)	cq1
				WRITE_SHORT		(itm_off + itm_num * 0x14 + 0xc)	cq2
				WRITE_SHORT		(itm_off + itm_num * 0x14 + 0xe)	cq3
				WRITE_LONG		(itm_off + itm_num * 0x14 + 0x10)	flag
				PATCH_IF	equip	BEGIN
					PATCH_MATCH	slot
					WITH	9 11 13 15	BEGIN
							SET	index = (slot - 9) / 2
							WRITE_SHORT	(slt_off + 50 * 0x2)	index
							WRITE_SHORT	(slt_off + 51 * 0x2)	ability
						END	49	BEGIN
							WRITE_SHORT	(slt_off + 50 * 0x2)	1000
							WRITE_SHORT	(slt_off + 51 * 0x2)	ability
						END	DEFAULT
					END
				END
				WRITE_LONG	0x61a (THIS + itm_add)		//	Item count
				WRITE_LONG	0x61e	(THIS + itm_add * 0x14)	//	Effects offset
			END
		END
	END
	

	//	v1.0
	DEFINE_PATCH_FUNCTION	IWD2_REMOVE_CRE_ITEM
		STR_VAR
			item = ~~
	BEGIN
		READ_ASCII	0	sig	(8)
		PATCH_IF	~%sig%~	STRING_EQUAL	~CRE V2.2~	BEGIN
			INNER_PATCH_SAVE	item ~%item%~ BEGIN	INSERT_BYTES BUFFER_LENGTH 1	WRITE_BYTE (BUFFER_LENGTH - 1) 32	INSERT_BYTES 0 1	WRITE_BYTE	0 32	END
			TEXT_SPRINT	w ~[ %TAB%%WNL%%MNL%%LNL%]~
			LPF	IWD2_CRE_REINDEX	RET	slt_off	itm_off	itm_num	fx_off	END
			TO_UPPER	item
			SET	itm_add = 0
			PATCH_IF	~%item%~ STRING_EQUAL ~~	BEGIN
				DELETE_BYTES	itm_off	(itm_num * 0x14)
				FOR (j = 0; j < 50;	++j)	BEGIN
					WRITE_SHORT	(slt_off + j * 0x2)	~-1~
				END
				SET	itm_add -= itm_num
			END	ELSE	BEGIN
				FOR	(i = 0; i < itm_num; ++i)	BEGIN
					READ_ASCII	(itm_off + i * 0x14)	resref
					TO_UPPER resref
					PATCH_IF	! ~%item%~ STRING_CONTAINS_REGEXP ~%w%%resref%%w%~	BEGIN
						DELETE_BYTES	(itm_off + i * 0x14)	0x14
						FOR (j = 0; j < 50;	++j)	BEGIN
							READ_SSHORT	(slt_off + j * 0x2)	slot
							PATCH_IF	slot > i	BEGIN
								WRITE_SHORT	(slt_off + j * 0x2) (THIS - 1)
							END
							PATCH_IF	slot = i	BEGIN
								WRITE_SHORT	(slt_off + j * 0x2)	~-1~
							END
						END
						SET	itm_add -= 1	SET	i -= 1	SET	itm_num -= 1
					END
				END
			END
			WRITE_LONG	0x61a (THIS + itm_add)		//	Item count
			WRITE_LONG	0x61e	(THIS + itm_add * 0x14)	//	Effects offset
		END
	END

	//	v1.0
	DEFINE_PATCH_FUNCTION	IWD2_CRE_REINDEX
		RET
			ba_0_off ba_0_num ba_1_off ba_1_num ba_2_off ba_2_num ba_3_off ba_3_num ba_4_off ba_4_num ba_5_off ba_5_num ba_6_off ba_6_num ba_7_off ba_7_num ba_8_off ba_8_num
			cl_0_off cl_0_num cl_1_off cl_1_num cl_2_off cl_2_num cl_3_off cl_3_num cl_4_off cl_4_num cl_5_off cl_5_num cl_6_off cl_6_num cl_7_off cl_7_num cl_8_off cl_8_num
			dr_0_off dr_0_num dr_1_off dr_1_num dr_2_off dr_2_num dr_3_off dr_3_num dr_4_off dr_4_num dr_5_off dr_5_num dr_6_off dr_6_num dr_7_off dr_7_num dr_8_off dr_8_num
			pa_0_off pa_0_num pa_1_off pa_1_num pa_2_off pa_2_num pa_3_off pa_3_num pa_4_off pa_4_num pa_5_off pa_5_num pa_6_off pa_6_num pa_7_off pa_7_num pa_8_off pa_8_num
			ra_0_off ra_0_num ra_1_off ra_1_num ra_2_off ra_2_num ra_3_off ra_3_num ra_4_off ra_4_num ra_5_off ra_5_num ra_6_off ra_6_num ra_7_off ra_7_num ra_8_off ra_8_num
			so_0_off so_0_num so_1_off so_1_num so_2_off so_2_num so_3_off so_3_num so_4_off so_4_num so_5_off so_5_num so_6_off so_6_num so_7_off so_7_num so_8_off so_8_num
			wi_0_off wi_0_num wi_1_off wi_1_num wi_2_off wi_2_num wi_3_off wi_3_num wi_4_off wi_4_num wi_5_off wi_5_num wi_6_off wi_6_num wi_7_off wi_7_num wi_8_off wi_8_num
			do_0_off do_0_num do_1_off do_1_num do_2_off do_2_num do_3_off do_3_num do_4_off do_4_num do_5_off do_5_num do_6_off do_6_num do_7_off do_7_num do_8_off do_8_num
			ab_off ab_num sng_off	sng_num	shp_off	shp_num	slt_off	itm_off	itm_num	fx_off	fx_num
	BEGIN
		FOR	(i = 0; i < 9; ++i)	BEGIN
			READ_LONG	(0x3ba + i * 4) $ba(~%i%~ ~off~)	READ_LONG	(0x4b6 + i * 4)	EVAL $ba(~%i%~ ~num~)	SET	$ba(~%i%~ ~size~)	 = ($ba(~%i%~ ~num~) * 0x10 + 8)	READ_ASCII	$ba(~%i%~ ~off~)	EVAL $ba(~%i%~)	($ba(~%i%~ ~size~))
			READ_LONG	(0x3de + i * 4) $cl(~%i%~ ~off~)	READ_LONG	(0x4da + i * 4)	EVAL $cl(~%i%~ ~num~)	SET	$cl(~%i%~ ~size~)	 = ($cl(~%i%~ ~num~) * 0x10 + 8)	READ_ASCII	$cl(~%i%~ ~off~)	EVAL $cl(~%i%~)	($cl(~%i%~ ~size~))
			READ_LONG	(0x402 + i * 4) $dr(~%i%~ ~off~)	READ_LONG	(0x4fe + i * 4)	EVAL $dr(~%i%~ ~num~)	SET	$dr(~%i%~ ~size~)	 = ($dr(~%i%~ ~num~) * 0x10 + 8)	READ_ASCII	$dr(~%i%~ ~off~)	EVAL $dr(~%i%~)	($dr(~%i%~ ~size~))
			READ_LONG	(0x426 + i * 4) $pa(~%i%~ ~off~)	READ_LONG	(0x522 + i * 4)	EVAL $pa(~%i%~ ~num~)	SET	$pa(~%i%~ ~size~)	 = ($pa(~%i%~ ~num~) * 0x10 + 8)	READ_ASCII	$pa(~%i%~ ~off~)	EVAL $pa(~%i%~)	($pa(~%i%~ ~size~))
			READ_LONG	(0x44a + i * 4)	$ra(~%i%~ ~off~)	READ_LONG	(0x546 + i * 4)	EVAL $ra(~%i%~ ~num~)	SET	$ra(~%i%~ ~size~)	 = ($ra(~%i%~ ~num~) * 0x10 + 8)	READ_ASCII	$ra(~%i%~ ~off~)	EVAL $ra(~%i%~)	($ra(~%i%~ ~size~))
			READ_LONG	(0x46e + i * 4) $so(~%i%~ ~off~)	READ_LONG	(0x56a + i * 4)	EVAL $so(~%i%~ ~num~)	SET	$so(~%i%~ ~size~)	 = ($so(~%i%~ ~num~) * 0x10 + 8)	READ_ASCII	$so(~%i%~ ~off~)	EVAL $so(~%i%~)	($so(~%i%~ ~size~))
			READ_LONG	(0x492 + i * 4) $wi(~%i%~ ~off~)	READ_LONG	(0x58e + i * 4)	EVAL $wi(~%i%~ ~num~)	SET	$wi(~%i%~ ~size~)	 = ($wi(~%i%~ ~num~) * 0x10 + 8)	READ_ASCII	$wi(~%i%~ ~off~)	EVAL $wi(~%i%~)	($wi(~%i%~ ~size~))
			READ_LONG	(0x5b2 + i * 4) $do(~%i%~ ~off~)	READ_LONG	(0x5d6 + i * 4)	EVAL $do(~%i%~ ~num~)	SET	$do(~%i%~ ~size~)	 = ($do(~%i%~ ~num~) * 0x10 + 8)	READ_ASCII	$do(~%i%~ ~off~)	EVAL $do(~%i%~)	($do(~%i%~ ~size~))
		END
		READ_LONG	0x5fa ab_off	READ_LONG	0x5fe	ab_num	SET	ab_size = (ab_num * 0x10 + 8)		READ_ASCII	ab_off	abilities	(ab_size)
		READ_LONG	0x602	sng_off	READ_LONG	0x606	sng_num	SET	sng_size = (sng_num * 0x10 + 8)	READ_ASCII	sng_off	songs	(sng_size)
		READ_LONG	0x60a	shp_off	READ_LONG	0x60e	shp_num	SET	shp_size = (shp_num * 0x10 + 8)	READ_ASCII	shp_off	shapes	(shp_size)
		READ_LONG	0x612	slt_off																															READ_ASCII	slt_off	slots	(0x68)
		READ_LONG	0x616	itm_off	READ_LONG	0x61a	itm_num	SET	itm_size = (itm_num * 0x14)			READ_ASCII	itm_off	items	(itm_size)
		READ_LONG	0x61e	fx_off	READ_LONG	0x622	fx_num	SET	fx_size = (fx_num * 0x108)			READ_ASCII	fx_off	effects	(fx_size)
		SET	offset = 0x62e
		PATCH_IF	(ba_0_off > ba_1_off) OR (ba_1_off > ba_2_off) OR (ba_2_off > ba_3_off) OR (ba_3_off > ba_4_off) OR
							(ba_4_off > ba_5_off) OR (ba_5_off > ba_6_off) OR (ba_6_off > ba_7_off) OR (ba_7_off > ba_8_off) OR (ba_8_off > cl_0_off) OR
							(cl_0_off > cl_1_off) OR (cl_1_off > cl_2_off) OR (cl_2_off > cl_3_off) OR (cl_3_off > cl_4_off) OR
							(cl_4_off > cl_5_off) OR (cl_5_off > cl_6_off) OR (cl_6_off > cl_7_off) OR (cl_7_off > cl_8_off) OR (cl_8_num > dr_0_off) OR
							(dr_0_off > dr_1_off) OR (dr_1_off > dr_2_off) OR (dr_2_off > dr_3_off) OR (dr_3_off > dr_4_off) OR
							(dr_4_off > dr_5_off) OR (dr_5_off > dr_6_off) OR (dr_6_off > dr_7_off) OR (dr_7_off > dr_8_off) OR (dr_8_num > pa_0_off) OR
							(pa_0_off > pa_1_off) OR (pa_1_off > pa_2_off) OR (pa_2_off > pa_3_off) OR (pa_3_off > pa_4_off) OR
							(pa_4_off > pa_5_off) OR (pa_5_off > pa_6_off) OR (pa_6_off > pa_7_off) OR (pa_7_off > pa_8_off) OR (pa_8_num > ra_0_off) OR
							(ra_0_off > ra_1_off) OR (ra_1_off > ra_2_off) OR (ra_2_off > ra_3_off) OR (ra_3_off > ra_4_off) OR
							(ra_4_off > ra_5_off) OR (ra_5_off > ra_6_off) OR (ra_6_off > ra_7_off) OR (ra_7_off > ra_8_off) OR (ra_8_num > ra_0_off) OR
							(so_0_off > so_1_off) OR (so_1_off > so_2_off) OR (so_2_off > so_3_off) OR (so_3_off > so_4_off) OR
							(so_4_off > so_5_off) OR (so_5_off > so_6_off) OR (so_6_off > so_7_off) OR (so_7_off > so_8_off) OR (so_8_num > so_0_off) OR
							(wi_0_off > wi_1_off) OR (wi_1_off > wi_2_off) OR (wi_2_off > wi_3_off) OR (wi_3_off > wi_4_off) OR
							(wi_4_off > wi_5_off) OR (wi_5_off > wi_6_off) OR (wi_6_off > wi_7_off) OR (wi_7_off > wi_8_off) OR (wi_8_num > wi_0_off) OR
							(do_0_off > do_1_off) OR (do_1_off > do_2_off) OR (do_2_off > do_3_off) OR (do_3_off > do_4_off) OR
							(do_4_off > do_5_off) OR (do_5_off > do_6_off) OR (do_6_off > do_7_off) OR (do_7_off > do_8_off) OR (do_8_num > ab_off) OR
							(ab_off > sng_off) OR (sng_off > shp_off) OR (shp_off > slt_off) OR (slt_off >= itm_off) OR (itm_off > fx_off) BEGIN
			SET	ba_0_off	= offset	WRITE_LONG	0x3ba	ba_0_off	WRITE_ASCIIE	ba_0_off	~%ba_0%~
			FOR	(i = 1; i < 9; ++i)	BEGIN	SET	j = i - 1	SET	$ba(~%i%~ ~off~)	= $ba(~%j%~ ~off~) + $ba(~%j%~ ~size~)	WRITE_LONG	(0x3ba + i * 4)	$ba(~%i%~ ~off~)	WRITE_ASCIIE	$ba(~%i%~ ~off~)	$ba(~%i%~)	END
			SET	cl_0_off	= ba_8_off + ba_8_size	WRITE_LONG	0x3de	cl_0_off	WRITE_ASCIIE	cl_0_off	~%cl_0%~
			FOR	(i = 1; i < 9; ++i)	BEGIN	SET	j = i - 1	SET	$cl(~%i%~ ~off~)	= $cl(~%j%~ ~off~) + $cl(~%j%~ ~size~)	WRITE_LONG	(0x3de + i * 4)	$cl(~%i%~ ~off~)	WRITE_ASCIIE	$cl(~%i%~ ~off~)	$cl(~%i%~)	END
			SET	dr_0_off	= cl_8_off + cl_8_size	WRITE_LONG	0x402	dr_0_off	WRITE_ASCIIE	dr_0_off	~%dr_0%~
			FOR	(i = 1; i < 9; ++i)	BEGIN	SET	j = i - 1	SET	$dr(~%i%~ ~off~)	= $dr(~%j%~ ~off~) + $dr(~%j%~ ~size~)	WRITE_LONG	(0x402 + i * 4)	$dr(~%i%~ ~off~)	WRITE_ASCIIE	$dr(~%i%~ ~off~)	$dr(~%i%~)	END
			SET	pa_0_off	= dr_8_off + dr_8_size	WRITE_LONG	0x426	pa_0_off	WRITE_ASCIIE	pa_0_off	~%pa_0%~
			FOR	(i = 1; i < 9; ++i)	BEGIN	SET	j = i - 1	SET	$pa(~%i%~ ~off~)	= $pa(~%j%~ ~off~) + $pa(~%j%~ ~size~)	WRITE_LONG	(0x426 + i * 4)	$pa(~%i%~ ~off~)	WRITE_ASCIIE	$pa(~%i%~ ~off~)	$pa(~%i%~)	END
			SET	ra_0_off	= pa_8_off + pa_8_size	WRITE_LONG	0x44a	ra_0_off	WRITE_ASCIIE	ra_0_off	~%ra_0%~
			FOR	(i = 1; i < 9; ++i)	BEGIN	SET	j = i - 1	SET	$ra(~%i%~ ~off~)	= $ra(~%j%~ ~off~) + $ra(~%j%~ ~size~)	WRITE_LONG	(0x44a + i * 4)	$ra(~%i%~ ~off~)	WRITE_ASCIIE	$ra(~%i%~ ~off~)	$ra(~%i%~)	END
			SET	so_0_off	= ra_8_off + ra_8_size	WRITE_LONG	0x46e	so_0_off	WRITE_ASCIIE	so_0_off	~%so_0%~
			FOR	(i = 1; i < 9; ++i)	BEGIN	SET	j = i - 1	SET	$so(~%i%~ ~off~)	= $so(~%j%~ ~off~) + $so(~%j%~ ~size~)	WRITE_LONG	(0x46e + i * 4)	$so(~%i%~ ~off~)	WRITE_ASCIIE	$so(~%i%~ ~off~)	$so(~%i%~)	END
			SET	wi_0_off	= so_8_off + so_8_size	WRITE_LONG	0x492	wi_0_off	WRITE_ASCIIE	wi_0_off	~%wi_0%~
			FOR	(i = 1; i < 9; ++i)	BEGIN	SET	j = i - 1	SET	$wi(~%i%~ ~off~)	= $wi(~%j%~ ~off~) + $wi(~%j%~ ~size~)	WRITE_LONG	(0x492 + i * 4)	$wi(~%i%~ ~off~)	WRITE_ASCIIE	$wi(~%i%~ ~off~)	$wi(~%i%~)	END
			SET	do_0_off	= wi_8_off + wi_8_size	WRITE_LONG	0x5b2	do_0_off	WRITE_ASCIIE	do_0_off	~%do_0%~
			FOR	(i = 1; i < 9; ++i)	BEGIN	SET	j = i - 1	SET	$do(~%i%~ ~off~)	= $do(~%j%~ ~off~) + $do(~%j%~ ~size~)	WRITE_LONG	(0x5b2 + i * 4)	$do(~%i%~ ~off~)	WRITE_ASCIIE	$do(~%i%~ ~off~)	$do(~%i%~)	END
				
			SET	ab_off	= do_8_off + do_8_size	WRITE_LONG	0x5fa	ab_off	WRITE_ASCIIE	ab_off	~%abilities%~
			SET	sng_off	= ab_off + ab_size			WRITE_LONG	0x602	sng_off	WRITE_ASCIIE	sng_off	~%songs%~
			SET	shp_off	= sng_off + sng_size		WRITE_LONG	0x60a	shp_off	WRITE_ASCIIE	shp_off	~%shapes%~
			SET	slt_off	= shp_off + shp_size		WRITE_LONG	0x612	slt_off	WRITE_ASCIIE	slt_off	~%slots%~
			SET	itm_off	= slt_off + 0x68				WRITE_LONG	0x616	itm_off	WRITE_ASCIIE	itm_off	~%items%~
			SET	fx_off	= itm_off + itm_size		WRITE_LONG	0x61e	fx_off	WRITE_ASCIIE	fx_off	~%effects%~
		END
	END

DEFINE_PATCH_FUNCTION ~ADD_CRE_EXTENDED_FEAT~
	INT_VAR
		points=1
	STR_VAR
		name=~~
BEGIN
	theid = 0
	INNER_ACTION BEGIN
		SILENT
		COPY_EXISTING ~b3feats.2da~ ~override~
			COUNT_2DA_ROWS 4 numrows
			FOR (i = 0; i < numrows; ++i) BEGIN
				READ_2DA_ENTRY i 0 4 thename
				PATCH_IF (~%name%~ STRING_EQUAL_CASE ~%thename%~) BEGIN
					READ_2DA_ENTRY i 1 4 theid
				END
			END
			IF_EXISTS
			BUT_ONLY_IF_IT_CHANGES
		VERBOSE
	END

	PATCH_IF theid > 0 BEGIN
		READ_BYTE (0x1A8 + theid) currentpoints
		FOR (i = currentpoints + 1; i <= points; ++i) BEGIN
			thenumeffects = 0
			theopcode = 0xDEFA
			theparameter1 = 0xDEFA
			theparameter2 = 0xDEFA
			thespecial = 0xDEFA
			thetiming = 0xDE
			thesavingthrow = 0xDEFA
			TEXT_SPRINT theresource ~DEFA~
			INNER_ACTION BEGIN
				COPY_EXISTING ~FE_%theid%_%i%.spl~ ~override~
					READ_LONG 0x6A theeffectoffset
					READ_SHORT 0xA0 thenumeffects
					READ_SHORT 0xA2 thefirsteffectindex
					IF_EXISTS
					BUT_ONLY_IF_IT_CHANGES
			END
			FOR (j = 0; j < thenumeffects; ++j) BEGIN
				INNER_ACTION BEGIN
					COPY_EXISTING ~FE_%theid%_%i%.spl~ ~override~
						thecurrenteffectoffset = (theeffectoffset + (thefirsteffectindex + j) * 0x30)
						READ_SHORT thecurrenteffectoffset theopcode ELSE 0xDEFA
						READ_LONG (thecurrenteffectoffset + 0x4) theparameter1 ELSE 0xDEFA
						READ_LONG (thecurrenteffectoffset + 0x8) theparameter2 ELSE 0xDEFA
						READ_LONG (thecurrenteffectoffset + 0x2C) thespecial ELSE 0xDEFA
						READ_BYTE (thecurrenteffectoffset + 0xC) thetiming ELSE 0xDE
						READ_LONG (thecurrenteffectoffset + 0x24) thesavingthrow ELSE 0xDEFA
						READ_ASCII (thecurrenteffectoffset + 0x14) theresource ELSE ~DEFA~
						IF_EXISTS
						BUT_ONLY_IF_IT_CHANGES
				END

				PATCH_IF theopcode = 171 BEGIN
					LPF	IWD2_CRE_ABILITY INT_VAR num=1 STR_VAR resource= EVAL ~%theresource%~ END
				END ELSE PATCH_IF theopcode != 0xDEFA BEGIN
					LPF IWD2_ADD_CRE_EFFECT INT_VAR opcode=theopcode target=1 timing=thetiming parameter1=theparameter1 parameter2=theparameter2 special=thespecial savingthrow=thesavingthrow STR_VAR resource= EVAL ~%theresource%~ effsource= EVAL ~FE_%theid%_%i%~ END
				END
			END

		END
		WRITE_BYTE (0x1A8 + theid) points
		thebit = theid - 64
		theoffset = 0x1C8 + (thebit / 32) * 4
		thebit = (thebit MODULO 32)
		featvalue = 1
		FOR (i = 0; i < thebit; ++i) BEGIN
			featvalue *= 2
		END
		READ_LONG theoffset thefeatlist
		thefeatlist |= featvalue
		WRITE_LONG theoffset thefeatlist
		LPF IWD2_ADD_CRE_EFFECT INT_VAR opcode=187 target=0 timing=1 parameter1=points STR_VAR effvar= EVAL ~%name%~ END
	END

END

DEFINE_PATCH_FUNCTION ~REPLACE_AREA_ITEM_IWD2~
	INT_VAR
		single_match=0
		charges1=~-1~
		charges2=~-1~
		charges3=~-1~
		container=0
		silent=0
	STR_VAR
		old_item=~~
		new_item=~~
		flags=~same~
BEGIN
	SET item_name_length = (STRING_LENGTH ~%old_item%~)
	PATCH_IF (~%flags%~ STRING_EQUAL_CASE ~same~) BEGIN
		SET flag = 0xDEFA
	END ELSE BEGIN
	SET	flag = 0
	PATCH_IF	! ~%flags%~	STRING_CONTAINS_REGEXP	~identified~	BEGIN SET	flag |= 1	END
	PATCH_IF	! ~%flags%~	STRING_CONTAINS_REGEXP	~unstealable~	BEGIN SET	flag |= 2	END
	PATCH_IF	! ~%flags%~	STRING_CONTAINS_REGEXP	~stolen~		BEGIN SET	flag |= 4	END
	PATCH_IF	! ~%flags%~	STRING_CONTAINS_REGEXP	~undroppable~	BEGIN SET	flag |= 8	END
	END
	SET item_found = 0
	READ_SHORT 0x86 itemnumber
	READ_LONG 0x88 itemoffset
	PATCH_IF container > 0 BEGIN
		READ_LONG 0x80 containeroffset
		READ_LONG (containeroffset + (container - 1) * 0xc0 + 0x40) firstitemindex
		READ_LONG (containeroffset + (container - 1) * 0xc0 + 0x44) itemnumber
		itemoffset = itemoffset + (firstitemindex * 0x14)
	END
	FOR (i = 0; i < itemnumber; ++i) BEGIN
		SET offset = itemoffset + (i * 0x14)
		READ_ASCII offset name_of_item (item_name_length)
		PATCH_IF (~%name_of_item%~ STRING_EQUAL_CASE ~%old_item%~) BEGIN
			item_found = 1
			WRITE_ASCIIE offset ~%new_item%~ #8
			PATCH_IF (charges1 != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0xa) charges1
			END
			PATCH_IF (charges2 != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0xc) charges2
			END
			PATCH_IF (charges3 != (0 - 1)) BEGIN
				WRITE_SHORT (offset + 0xe) charges3
			END
			PATCH_IF (flag != 0xDEFA) BEGIN
				WRITE_LONG (offset + 0x10) flag
			END


			PATCH_IF (single_match = 1) BEGIN
				i = itemnumber
			END
			
		END
	END
	PATCH_IF (item_found = 0 AND silent = 0) BEGIN
		PATCH_WARN ~No item called %old_item% was found.~
	END

END

DEFINE_PATCH_FUNCTION ~SET_CLASS_LEVELS_IWD2~
	INT_VAR
		newlevelbarbarian=0
		newlevelbard=0
		newlevelcleric=0
		newleveldruid=0
		newlevelfighter=0
		newlevelmonk=0
		newlevelpaladin=0
		newlevelranger=0
		newlevelrogue=0
		newlevelsorcerer=0
		newlevelwizard=0
	STR_VAR
		updatehp=~~
BEGIN
	WRITE_BYTE levelbarbarian newlevelbarbarian
	WRITE_BYTE levelbard newlevelbard
	WRITE_BYTE levelcleric newlevelcleric
	WRITE_BYTE leveldruid newleveldruid
	WRITE_BYTE levelfighter newlevelfighter
	WRITE_BYTE levelmonk newlevelmonk
	WRITE_BYTE levelpaladin newlevelpaladin
	WRITE_BYTE levelranger newlevelranger
	WRITE_BYTE levelrogue newlevelrogue
	WRITE_BYTE levelsorcerer newlevelsorcerer
	WRITE_BYTE levelwizard newlevelwizard
	newleveltotal = (newlevelbarbarian + newlevelbard + newlevelcleric + newleveldruid + newlevelfighter + newlevelmonk + newlevelpaladin + newlevelranger + newlevelrogue + newlevelsorcerer + newlevelwizard)
	WRITE_BYTE leveltotal newleveltotal
	PATCH_IF ~%updatehp%~ STRING_EQUAL_CASE ~average~ BEGIN
		newhp = (newlevelbarbarian * 6 + newlevelbard * 3 + newlevelcleric * 4 + newleveldruid * 4 + newlevelfighter * 5 + newlevelmonk * 4 + newlevelpaladin * 5 + newlevelranger * 5 + newlevelrogue * 3 + newlevelsorcerer * 2 + newlevelwizard * 2 + newleveltotal / 2)
		WRITE_SHORT currenthp newhp
		WRITE_SHORT maxhp newhp
	END	ELSE PATCH_IF ~%updatehp%~ STRING_EQUAL_CASE ~max~ OR ~%updatehp%~ STRING_EQUAL_CASE ~maximum~ BEGIN
		newhp = (newlevelbarbarian * 12 + newlevelbard * 6 + newlevelcleric * 8 + newleveldruid * 8 + newlevelfighter * 10 + newlevelmonk * 8 + newlevelpaladin * 10 + newlevelranger * 10 + newlevelrogue * 6 + newlevelsorcerer * 4 + newlevelwizard * 4)
		WRITE_SHORT currenthp newhp
		WRITE_SHORT maxhp newhp
	END
	newclassmask = 0
	PATCH_IF newlevelbarbarian > 0 BEGIN
		newclassmask|=0x1
	END
	PATCH_IF newlevelbard > 0 BEGIN
		newclassmask|=0x2
	END
	PATCH_IF newlevelcleric > 0 BEGIN
		newclassmask|=0x4
	END
	PATCH_IF newleveldruid > 0 BEGIN
		newclassmask|=0x8
	END
	PATCH_IF newlevelfighter > 0 BEGIN
		newclassmask|=0x10
	END
	PATCH_IF newlevelmonk > 0 BEGIN
		newclassmask|=0x20
	END
	PATCH_IF newlevelpaladin > 0 BEGIN
		newclassmask|=0x40
	END
	PATCH_IF newlevelranger > 0 BEGIN
		newclassmask|=0x80
	END
	PATCH_IF newlevelrogue > 0 BEGIN
		newclassmask|=0x100
	END
	PATCH_IF newlevelsorcerer > 0 BEGIN
		newclassmask|=0x200
	END
	PATCH_IF newlevelwizard > 0 BEGIN
		newclassmask|=0x400
	END
	WRITE_LONG 0x3B6 newclassmask
END

DEFINE_ACTION_FUNCTION ~ADD_FEAT_IWD2~
	INT_VAR
		nameref=0
		descref=0
		max=1
	STR_VAR
		name=~~
		points=~0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0                       0~
		script=~Feats_True~
		prerequisite_script=~~
		featspl_1=~NoSpellForThis~
		featspl_2=~NoSpellForThis~
		featspl_3=~NoSpellForThis~
		featspl_4=~NoSpellForThis~
		featspl_5=~NoSpellForThis~
BEGIN
	ACTION_IF (~%prerequisite_script%~ STRING_EQUAL_CASE ~~) BEGIN
		OUTER_SPRINT prerequisite_script ~%script%~
	END
	COPY_EXISTING ~b3feats.2da~ ~override~
		COUNT_2DA_ROWS 5 numrows
		nextid = numrows + 75
		INSERT_2DA_ROW (numrows + 1) 4 ~%name% %nextid% %max% %prerequisite_script% %script%~

	COPY_EXISTING ~feats.2da~ ~override~
		COUNT_2DA_COLS numcols
		COUNT_2DA_ROWS numcols numrows
		INSERT_2DA_ROW numrows numcols ~%name% %nextid% %nameref% %descref% %points%~

	COPY_EXISTING ~%featspl_1%.spl~ ~override/FE_%nextid%_1.spl~ ~%featspl_2%.spl~ ~override/FE_%nextid%_2.spl~ ~%featspl_3%.spl~ ~override/FE_%nextid%_3.spl~ ~%featspl_4%.spl~ ~override/FE_%nextid%_4.spl~ ~%featspl_5%.spl~ ~override/FE_%nextid%_5.spl~
		IF_EXISTS

	COPY_EXISTING ~IEex_WEIDU.lua~ ~override~
		REPLACE_TEXTUALLY ~ex_feat_name_id = {~ ~ex_feat_name_id = {["%name%"] = %nextid%, ~
END

DEFINE_PATCH_FUNCTION ~CONVERT_DLG_TO_IWD2_FORMAT~
BEGIN
	READ_LONG 0xc ulgiash
	PATCH_IF (ulgiash = 0x34) BEGIN
		DELETE_BYTES 0x30 4

		READ_LONG 0xc ulgiash
		ulgiash -= 4
		WRITE_LONG 0xc ulgiash
	
		READ_LONG 0x14 ulgiash
		ulgiash -= 4
		WRITE_LONG 0x14 ulgiash

		READ_LONG 0x18 ulgiash
		ulgiash -= 4
		WRITE_LONG 0x18 ulgiash
		READ_LONG ulgiash ulgiash
		INSERT_BYTES (ulgiash - 2) 2
		
		READ_LONG 0x20 ulgiash
		ulgiash -= 4
		WRITE_LONG 0x20 ulgiash
	
		READ_LONG 0x28 ulgiash
		ulgiash -= 4
		WRITE_LONG 0x28 ulgiash
		READ_LONG ulgiash ulgiash
		INSERT_BYTES (ulgiash - 2) 2
	END
END

DEFINE_PATCH_FUNCTION ~GET_2DA_ROW~
	INT_VAR
		starting_row=0
		numcolumns=0
		match_column=0
		found_it=0
	STR_VAR
		match=~DEFA~
	RET
		numcols
		matched
BEGIN
		COUNT_2DA_ROWS numcolumns numrows
		FOR (i = starting_row; i < numrows; ++i) BEGIN
			READ_2DA_ENTRY i match_column numcolumns string_to_match
			PATCH_IF (~%string_to_match%~ STRING_EQUAL_CASE ~%match%~) BEGIN
				matched = i
				found_it = 1
				i = numrows

			END
		END
		numcols = numcolumns
		PATCH_IF (found_it = 0) BEGIN
			PATCH_FAIL ~GET_2DA_ROW: Could not find a row that contains %match% in column %match_column%.~
		END
END

DEFINE_ACTION_FUNCTION ~ACTION_APPEND_TO_STRING~
	INT_VAR
		strref=(0 - 1)
		new_string=0
		append_top=0
	STR_VAR
		newtext=~~
	RET
		new_strref
		description_new
BEGIN
	ACTION_GET_STRREF strref description_old
	ACTION_IF append_top = 0 BEGIN
		OUTER_SPRINT description_new ~%description_old%~ ^ ~%newtext%~
	END ELSE BEGIN
		OUTER_SPRINT description_new ~%newtext%~ ^ ~%description_old%~
	END
	ACTION_IF new_string = 0 BEGIN
		STRING_SET_EVALUATE strref ~%description_new%~
	END
	OUTER_SET new_strref = RESOLVE_STR_REF(~%description_new%~)
END

DEFINE_PATCH_FUNCTION ~PATCH_APPEND_TO_STRING~
	INT_VAR
		strref=(0 - 1)
		new_string=0
		append_top=0
	STR_VAR
		newtext=~~
	RET
		new_strref
		description_new
BEGIN
	GET_STRREF strref description_old
	PATCH_IF append_top = 0 BEGIN
		SPRINT description_new ~%description_old%~ ^ ~%newtext%~
	END ELSE BEGIN
		SPRINT description_new ~%newtext%~ ^ ~%description_old%~
	END
	PATCH_IF new_string = 0 BEGIN
		INNER_ACTION BEGIN
			STRING_SET_EVALUATE strref ~%description_new%~
		END
	END
	new_strref = RESOLVE_STR_REF(~%description_new%~)
END

DEFINE_ACTION_FUNCTION ~ACTION_REPLACE_IN_STRING~
	INT_VAR
		strref=(0 - 1)
		match_case=0
		new_string=0
	STR_VAR
		match=~DEFA~
		replace_with=~~
	RET
		new_strref
		description_new
BEGIN
	ACTION_GET_STRREF strref description_old
	OUTER_PATCH_SAVE description_new ~%description_old%~ BEGIN
		PATCH_IF match_case = 0 BEGIN
			REPLACE_TEXTUALLY CASE_INSENSITIVE ~%match%~ ~%replace_with%~
		END
		ELSE BEGIN
			REPLACE_TEXTUALLY CASE_SENSITIVE ~%match%~ ~%replace_with%~
		END
	END
	ACTION_IF new_string = 0 BEGIN
		STRING_SET_EVALUATE strref ~%description_new%~
	END
	OUTER_SET new_strref = RESOLVE_STR_REF(~%description_new%~)
END

DEFINE_PATCH_FUNCTION ~PATCH_REPLACE_IN_STRING~
	INT_VAR
		strref=(0 - 1)
		match_case=0
		new_string=0
	STR_VAR
		match=~DEFA~
		replace_with=~~
	RET
		new_strref
		description_new
BEGIN
	GET_STRREF strref description_old
	INNER_PATCH_SAVE description_new ~%description_old%~ BEGIN
		PATCH_IF match_case = 0 BEGIN
			REPLACE_TEXTUALLY CASE_INSENSITIVE ~%match%~ ~%replace_with%~
		END
		ELSE BEGIN
			REPLACE_TEXTUALLY CASE_SENSITIVE ~%match%~ ~%replace_with%~
		END
	END
	PATCH_IF new_string = 0 BEGIN
		INNER_ACTION BEGIN
			STRING_SET_EVALUATE strref ~%description_new%~
		END
	END
	new_strref = RESOLVE_STR_REF(~%description_new%~)
END

DEFINE_PATCH_FUNCTION	ADD_CHU_CONTROL
	INT_VAR
		panel = ~-1~
		x_coord = 0
		y_coord = 0
		width = 0
		height = 0
		type = 0
	STR_VAR
		image = ~~
	RET
		index
BEGIN
	controlsize = 0x20
	PATCH_IF type = 2 BEGIN
		controlsize = 0x34
	END ELSE PATCH_IF type = 3 BEGIN
		controlsize = 0x6A
	END ELSE PATCH_IF type = 5 BEGIN
		controlsize = 0x2E
	END ELSE PATCH_IF type = 6 BEGIN
		controlsize = 0x24
	END ELSE PATCH_IF type = 7 BEGIN
		controlsize = 0x28
	END
	READ_LONG 0x8 numpanels
	READ_LONG 0xC controlsoffset
	READ_LONG 0x10 panelsoffset
	READ_SHORT (panelsoffset + (panel * 0x1C) + 0xE) thepanelnumcontrols
	READ_SHORT (panelsoffset + (panel * 0x1C) + 0x18) thepanelfirstcontrolindex
	newcontrolindex = thepanelnumcontrols + thepanelfirstcontrolindex
	READ_LONG (controlsoffset + ((newcontrolindex - 1) * 0x8)) previouscontroloffset
	READ_LONG (controlsoffset + ((newcontrolindex - 1) * 0x8) + 0x4) previouscontrolsize
	newcontroloffset = previouscontroloffset + previouscontrolsize
	INSERT_BYTES newcontroloffset controlsize
	INSERT_BYTES (controlsoffset + (newcontrolindex * 0x8)) 0x8
	WRITE_LONG (controlsoffset + (newcontrolindex * 0x8)) newcontroloffset
	WRITE_LONG (controlsoffset + (newcontrolindex * 0x8) + 0x4) controlsize
	WRITE_SHORT (panelsoffset + (panel * 0x1C) + 0xE) (THIS + 1)
	FOR (i = panel + 1; i < numpanels; ++i) BEGIN
		WRITE_SHORT (panelsoffset + (i * 0x1C) + 0x18) (THIS + 1)
	END
	READ_SHORT (panelsoffset + ((numpanels - 1) * 0x1C) + 0xE) lastpanelnumcontrols
	READ_SHORT (panelsoffset + ((numpanels - 1) * 0x1C) + 0x18) lastpanelfirstcontrolindex
	numcontrols = lastpanelnumcontrols + lastpanelfirstcontrolindex
	FOR (i = 0; i < numcontrols; ++i) BEGIN
		WRITE_LONG (controlsoffset + (i * 0x8)) (THIS + 0x8)
	END
	FOR (i = newcontrolindex + 1; i < numcontrols; ++i) BEGIN
		WRITE_LONG (controlsoffset + (i * 0x8)) (THIS + controlsize)
	END
END

DEFINE_PATCH_FUNCTION ~ADD_ITEM_HEADER~
  INT_VAR
    type=3
    required_id=0
    location=3
    alt_dicesize=0
    target=1
    target_count=0
    range=0
    projectile_type=0
    alt_dicenumber=0
    speed=0
    alt_damage=0
    thaco=0
    dicesize=0
    school=0
    dicenumber=0
    sectype=0
    damage=0
    damage_type=0
    charges=0
    depletion=0
    flags=0
    projectile=1
    overhand=0
    backhand=0
    thrust=0
    is_bow=0
    is_xbow=0
    is_sling=0

    copy_header=0
    insert_point=~-1~
  STR_VAR
    icon=~~
  RET
    insert_point
BEGIN
  hs=0x38

  READ_LONG 0x64 ho
  READ_SHORT 0x68 hc
  READ_LONG 0x6a eo
  insert_point = (insert_point>hc || insert_point<0) ? hc : insert_point
  copy_header = (copy_header<0) ? 0 : copy_header

  PATCH_IF copy_header>hc BEGIN
    PATCH_WARN ~Unable to copy %copy_header%th header, %SOURCE_FILE% contains only %hc% headers!~
  END ELSE BEGIN
    INSERT_BYTES ho+insert_point*hs hs
    hc+=1
    eo+=hs
    PATCH_IF copy_header BEGIN
      READ_SHORT ho+(copy_header - 1)*hs+0x1e ec
      READ_SHORT ho+(copy_header - 1)*hs+0x20 ei
      READ_ASCII eo+ei*0x30 effs (ec*0x30)
      READ_ASCII ho+(copy_header - 1)*hs copy (hs)
      WRITE_ASCIIE ho+insert_point*hs ~%copy%~ (hs)
    END
    WRITE_SHORT 0x68 hc
    WRITE_LONG 0x6a eo

    READ_SHORT 0x70 ei
    FOR (i=ho;i<ho+hc*hs;i+=hs) BEGIN
      READ_SHORT i+0x1e ec
      WRITE_SHORT i+0x20 ei
      ei+=ec
    END

    PATCH_IF copy_header BEGIN
      READ_SHORT ho+insert_point*hs+0x1e ec
      READ_SHORT ho+insert_point*hs+0x20 ei
      INSERT_BYTES eo+ei*0x30 ec*0x30
      WRITE_ASCIIE eo+ei*0x30 ~%effs%~ (ec*0x30)
    END ELSE BEGIN
      off=ho+insert_point*hs
      WRITE_BYTE off type
      WRITE_BYTE off+0x1 required_id
      WRITE_BYTE off+0x2 location
      WRITE_BYTE off+0x3 alt_dicesize
      WRITE_ASCIIE off+0x4 ~%icon%~ (8)
      WRITE_BYTE off+0xc target
      WRITE_BYTE off+0xd target_count
      WRITE_SHORT off+0xe range
      WRITE_BYTE off+0x10 projectile_type
      WRITE_BYTE off+0x11 alt_dicenumber
      WRITE_BYTE off+0x12 speed
      WRITE_BYTE off+0x13 alt_damage
      WRITE_SHORT off+0x14 thaco
      WRITE_BYTE off+0x16 dicesize
      WRITE_BYTE off+0x17 school
      WRITE_BYTE off+0x18 dicenumber
      WRITE_BYTE off+0x19 sectype
      WRITE_SHORT off+0x1a damage
      WRITE_SHORT off+0x1c damage_type
      WRITE_SHORT off+0x22 charges
      WRITE_SHORT off+0x24 depletion
      WRITE_LONG off+0x26 flags
      WRITE_SHORT off+0x2a projectile
      WRITE_SHORT off+0x2c overhand
      WRITE_SHORT off+0x2e backhand
      WRITE_SHORT off+0x30 thrust
      WRITE_SHORT off+0x32 is_bow
      WRITE_SHORT off+0x34 is_xbow
      WRITE_SHORT off+0x36 is_sling
    END
  END
END

DEFINE_PATCH_FUNCTION ~ADD_SPELL_HEADER~
	INT_VAR
		type=1
		location=4
		target=1
		target_count=0
		range=0
		required_level=1
		speed=0
		projectile=1

		copy_header=0
		insert_point=~-1~
	STR_VAR
		icon=~~
	RET
		insert_point
BEGIN
  hs=0x28

  READ_LONG 0x64 ho
  READ_SHORT 0x68 hc
  READ_LONG 0x6a eo
  insert_point = (insert_point>hc || insert_point<0) ? hc : insert_point
  copy_header = (copy_header<0) ? 0 : copy_header

  PATCH_IF copy_header>hc BEGIN
    PATCH_WARN ~Unable to copy %copy_header%th header, %SOURCE_FILE% contains only %hc% headers!~
  END ELSE BEGIN
    INSERT_BYTES ho+insert_point*hs hs
    hc+=1
    eo+=hs
    PATCH_IF copy_header BEGIN
      READ_SHORT ho+(copy_header - 1)*hs+0x1e ec
      READ_SHORT ho+(copy_header - 1)*hs+0x20 ei
      READ_ASCII eo+ei*0x30 effs (ec*0x30)
      READ_ASCII ho+(copy_header - 1)*hs copy (hs)
      WRITE_ASCIIE ho+insert_point*hs ~%copy%~ (hs)
    END
    WRITE_SHORT 0x68 hc
    WRITE_LONG 0x6a eo

    READ_SHORT 0x70 ei
    FOR (i=ho;i<ho+hc*hs;i+=hs) BEGIN
      READ_SHORT i+0x1e ec
      WRITE_SHORT i+0x20 ei
      ei+=ec
    END

    PATCH_IF copy_header BEGIN
      READ_SHORT ho+insert_point*hs+0x1e ec
      READ_SHORT ho+insert_point*hs+0x20 ei
      INSERT_BYTES eo+ei*0x30 ec*0x30
      WRITE_ASCIIE eo+ei*0x30 ~%effs%~ (ec*0x30)
    END ELSE BEGIN
      off=ho+insert_point*hs
      WRITE_BYTE off type
      WRITE_BYTE off+0x2 location
      WRITE_ASCIIE off+0x4 ~%icon%~ (8)
      WRITE_BYTE off+0xc target
      WRITE_BYTE off+0xd target_count
      WRITE_SHORT off+0xe range
      WRITE_SHORT off+0x10 required_level
      WRITE_LONG off+0x12 speed
      WRITE_SHORT off+0x26 projectile
    END
  END
END